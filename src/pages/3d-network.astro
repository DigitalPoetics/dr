---
import BaseLayout from '../layouts/BaseLayout.astro';
import Figure from '../components/ui/Figure.astro';

const pageTitle = "POETRY NETWORK"
const description = "Interactive Three.js visualization of postwar U.S. poetry networks, made with Claude Sonnet 4.5 and based on the cosmos visualization on the welcome page";

---

<BaseLayout pageTitle={pageTitle} description={description}>
    <p class="title-page">Interactive Three.js visualization of postwar U.S. poetry networks</p>
    <div id="viz-container">
        <canvas id="network-canvas"></canvas>
        <div id="node-info">
            <div id="info-content">Drag to rotate â€¢ Scroll to zoom</div>
        </div>
    </div>
    <h3 class="title-page">MADE WITH</h3>
    <h1 class="title-page"><a href="https://www.anthropic.com/news/claude-sonnet-4-5" target="_blank">Claude Sonnet 4.5</a></h1>
    <p class="title-page">Based on the cosmos visualization on <a href="https://claud<mark marker-index=6 reference-tracker>e.com/product/claude-code" target="_blank">Claude Code</a></p>
</BaseLayout>

<script is:inline src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js" defer></script>
<script is:inline src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js" defer></script>


<script is:inline>
    // ============================================================================
    // CONFIGURATION PARAMETERS - Adjust these to customize the visualization
    // ============================================================================
    
    // Sphere & Layout
    const SPHERE_RADIUS = 30;
    const SPHERE_CENTER = { x: 0, y: 0, z: 0 };
    
    // Force-Directed Layout Parameters
    const ATTRACTION_STRENGTH = 0.8;
    const REPULSION_STRENGTH = 100;
    const CENTERING_STRENGTH = 0.01;
    const INITIAL_STEP_SIZE = 0.5;
    const COOLING_RATE = 0.997;
    const SIMULATION_ITERATIONS = 0;
    
    // Camera Settings
    const CAMERA_FOV = 50;
    const CAMERA_NEAR = 0.1;
    const CAMERA_FAR = 300;
    const CAMERA_INITIAL_Z = 80;
    
    // Camera Controls
    const ORBIT_ROTATE_SPEED = 0.5;
    const ORBIT_DAMPING_FACTOR = 0.05;
    const ORBIT_MIN_DISTANCE = 60;
    const ORBIT_MAX_DISTANCE = 300;
    
    // Node Size Ranges - Based on degree (number of connections)
    const NODE_SIZE_MEMBER_MIN = 0.1;
    const NODE_SIZE_MEMBER_MAX = 0.5;
    const NODE_SIZE_INSTITUTION_MIN = 0.2;
    const NODE_SIZE_INSTITUTION_MAX = 1.0;
    const NODE_OPACITY_POET = 0.7;
    const NODE_OPACITY_INSTITUTION = 0.9;
    
    // Node Colors
    const COLOR_POET = 0xC0C0C0;        // Silver
    const COLOR_AUDIO = 0xFFD700;       // Gold
    const COLOR_AVANT = 0xCD7F32;       // Bronze
    const COLOR_BAM = 0xB87333;         // Copper
    const COLOR_EMERGENT = 0xE5E4E2;    // Platinum
    const COLOR_FEMINIST = 0xE8B4B8;    // Rose gold
    const COLOR_NF = 0xF7E7CE;          // Champagne
    const COLOR_TEACHING = 0xFFBF00;    // Amber
    const COLOR_DEFAULT = 0x8aded8;
    
    // Selection & Highlighting
    // const SELECTED_COLOR = 0xFF0000;        // Red for selected nodes
    // const SELECTED_GLOW_COLOR = 0xFF0000;   // Red glow
    const SELECTED_COLOR = 0xFFFFFF;        // White center
    const SELECTED_GLOW_COLOR = 0xFF1493;   // Deep pink glow

    const GLOW_SIZE_MULTIPLIER = 2;
    const GLOW_OPACITY = 0.5;
    const INITIAL_SELECTED_NODES = ['Swensen_American Hybrid_2009'];      // Array of node names to pre-select
    
    // Edge Appearance
    const EDGE_COLOR = 0x191970;  // Midnight blue
    const EDGE_OPACITY = 0.1;
    
    // Particles
    const PARTICLE_COUNT = 100;
    const PARTICLE_SPREAD = 120;
    const PARTICLE_SIZE = 0.3;
    const PARTICLE_OPACITY = 0.3;
    const PARTICLE_COLOR = 0xD97757;
    const PARTICLE_ROTATION_SPEED_Y = 0.0005;
    const PARTICLE_ROTATION_SPEED_X = 0.0002;
    
    // Animation
    const NODE_PULSE_SPEED = 0.001;
    const NODE_PULSE_AMPLITUDE = 0.05;
    
    // Scene
    const SCENE_BACKGROUND_COLOR = 0x151515;
    const FOG_COLOR = 0x1E1E1E;
    const FOG_NEAR = 50;
    const FOG_FAR = 150;
    const MAX_PIXEL_RATIO = 2;
    
    // ============================================================================
    // END CONFIGURATION
    // ============================================================================

    const container = document.getElementById('viz-container');
    const containerWidth = container.clientWidth;
    const WIDTH = containerWidth;
    const containerHeight = container.clientHeight;
    const HEIGHT = containerHeight;

    async function initNetwork() {
        const [nodesData, linksData] = await Promise.all([
            fetch('/data/bimodal-network/nodes.json').then(r => r.json()),
            fetch('/data/bimodal-network/links.json').then(r => r.json())
        ]);

        const container = document.getElementById('viz-container');
        const canvas = document.getElementById('network-canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(SCENE_BACKGROUND_COLOR);
        scene.fog = new THREE.Fog(FOG_COLOR, FOG_NEAR, FOG_FAR);

        const camera = new THREE.PerspectiveCamera(CAMERA_FOV, WIDTH / HEIGHT, CAMERA_NEAR, CAMERA_FAR);
        camera.position.set(0, 0, CAMERA_INITIAL_Z);

        const renderer = new THREE.WebGLRenderer({
            powerPreference: 'low-power',
            canvas: canvas,
            antialias: true,
            alpha: true
        });
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, MAX_PIXEL_RATIO));

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = ORBIT_DAMPING_FACTOR;
        controls.rotateSpeed = ORBIT_ROTATE_SPEED;
        controls.enableZoom = true;
        controls.minDistance = ORBIT_MIN_DISTANCE;
        controls.maxDistance = ORBIT_MAX_DISTANCE;

        const colors = {
            poet: COLOR_POET,
            'Audio Archives': COLOR_AUDIO,
            'Avant-garde': COLOR_AVANT,
            'The Black Arts Movement': COLOR_BAM,
            'Emergent Poets': COLOR_EMERGENT,
            'The Feminist Poetry Movement': COLOR_FEMINIST,
            'New Formalism': COLOR_NF,
            'Teaching/Survey': COLOR_TEACHING,
            default: COLOR_DEFAULT
        };

        const nodeIndex = new Map();
        nodesData.forEach(node => {
            nodeIndex.set(node.name, node);
        });

        // Build neighbor and edge maps
        const nodeNeighbors = new Map();
        const nodeEdges = new Map();

        nodesData.forEach(node => {
            nodeNeighbors.set(node.name, []);
            nodeEdges.set(node.name, []);
        });

        linksData.forEach(link => {
            nodeNeighbors.get(link.source).push(link.target);
            nodeNeighbors.get(link.target).push(link.source);
        });

        // Calculate degree for each node
        const nodeDegree = new Map();
        nodesData.forEach(node => {
            nodeDegree.set(node.name, 0);
        });

        linksData.forEach(link => {
            nodeDegree.set(link.source, (nodeDegree.get(link.source) || 0) + 1);
            nodeDegree.set(link.target, (nodeDegree.get(link.target) || 0) + 1);
        });

        // Find min/max degrees per type
        let minDegreeMember = Infinity, maxDegreeMember = -Infinity;
        let minDegreeInstitution = Infinity, maxDegreeInstitution = -Infinity;

        nodesData.forEach(node => {
            const degree = nodeDegree.get(node.name);
            if (node.type === 'member') {
                minDegreeMember = Math.min(minDegreeMember, degree);
                maxDegreeMember = Math.max(maxDegreeMember, degree);
            } else if (node.type === 'institution') {
                minDegreeInstitution = Math.min(minDegreeInstitution, degree);
                maxDegreeInstitution = Math.max(maxDegreeInstitution, degree);
            }
        });

        function getNodeSize(node) {
            const degree = nodeDegree.get(node.name) || 0;
            
            if (node.type === 'institution') {
                if (maxDegreeInstitution === minDegreeInstitution) {
                    return (NODE_SIZE_INSTITUTION_MIN + NODE_SIZE_INSTITUTION_MAX) / 2;
                }
                const normalized = (degree - minDegreeInstitution) / (maxDegreeInstitution - minDegreeInstitution);
                return NODE_SIZE_INSTITUTION_MIN + normalized * (NODE_SIZE_INSTITUTION_MAX - NODE_SIZE_INSTITUTION_MIN);
            } else {
                if (maxDegreeMember === minDegreeMember) {
                    return (NODE_SIZE_MEMBER_MIN + NODE_SIZE_MEMBER_MAX) / 2;
                }
                const normalized = (degree - minDegreeMember) / (maxDegreeMember - minDegreeMember);
                return NODE_SIZE_MEMBER_MIN + normalized * (NODE_SIZE_MEMBER_MAX - NODE_SIZE_MEMBER_MIN);
            }
        }

        function randomPositionInSphere(radius) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = Math.cbrt(Math.random()) * radius;
            
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        // Class management functions
        function addClass(object, className) {
            if (!object.userData.classes) object.userData.classes = new Set();
            object.userData.classes.add(className);
        }

        function removeClass(object, className) {
            if (object.userData.classes) {
                object.userData.classes.delete(className);
            }
        }

        function hasClass(object, className) {
            return object.userData.classes && object.userData.classes.has(className);
        }

        function createGlow(nodeName) {
            const mesh = nodeMeshes.get(nodeName);
            if (!mesh || nodeMeshes.get(nodeName + '_glow')) return; // Already has glow
            
            const size = mesh.geometry.parameters.radius;
            const glowGeometry = new THREE.SphereGeometry(size * GLOW_SIZE_MULTIPLIER, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: SELECTED_GLOW_COLOR,
                transparent: true,
                opacity: GLOW_OPACITY,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(mesh.position);
            glow.userData = { classes: new Set() };
            scene.add(glow);
            nodeMeshes.set(nodeName + '_glow', glow);
        }

        function removeGlow(nodeName) {
            const glow = nodeMeshes.get(nodeName + '_glow');
            if (glow) {
                scene.remove(glow);
                nodeMeshes.delete(nodeName + '_glow');
            }
        }

        const nodePositions = new Map();
        const nodeVelocities = new Map();
        const nodeObjects = [];
        const nodeMeshes = new Map();

        nodesData.forEach((node) => {
            nodePositions.set(node.name, randomPositionInSphere(SPHERE_RADIUS));
            nodeVelocities.set(node.name, { x: 0, y: 0, z: 0 });

            const size = getNodeSize(node);
            const geometry = new THREE.SphereGeometry(size, 16, 16);

            const color = colors[node.group] || colors.default;
            const opacity = node.type === 'institution' ? NODE_OPACITY_INSTITUTION : NODE_OPACITY_POET;
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: opacity
            });

            const sphere = new THREE.Mesh(geometry, material);
            const pos = nodePositions.get(node.name);
            sphere.position.set(pos.x, pos.y, pos.z);
            sphere.userData = { 
                name: node.name, 
                group: node.group, 
                type: node.type,
                classes: new Set(),
                originalColor: color
            };

            scene.add(sphere);
            nodeObjects.push(sphere);
            nodeMeshes.set(node.name, sphere);

            // if (node.name === 'Swensen_American Hybrid_2009') {
            //     const glowGeometry = new THREE.SphereGeometry(size * GLOW_SIZE_MULTIPLIER, 16, 16);
            //     const glowMaterial = new THREE.MeshBasicMaterial({
            //         color: color,
            //         transparent: true,
            //         opacity: GLOW_OPACITY,
            //         blending: THREE.AdditiveBlending
            //     });
            //     const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            //     glow.position.set(pos.x, pos.y, pos.z);
            //     glow.userData = { classes: new Set() };
            //     scene.add(glow);
            //     nodeMeshes.set(node.name + '_glow', glow);
            // }
        });

        const lineMaterial = new THREE.LineBasicMaterial({
            color: EDGE_COLOR,
            transparent: true,
            opacity: EDGE_OPACITY,
            blending: THREE.AdditiveBlending
        });

        const edgeLines = [];
        linksData.forEach(link => {
            const sourcePos = nodePositions.get(link.source);
            const targetPos = nodePositions.get(link.target);

            if (sourcePos && targetPos) {
                const points = [
                    new THREE.Vector3(sourcePos.x, sourcePos.y, sourcePos.z),
                    new THREE.Vector3(targetPos.x, targetPos.y, targetPos.z)
                ];

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                line.userData = { 
                    classes: new Set(),
                    originalColor: EDGE_COLOR
                };
                scene.add(line);
                edgeLines.push({ line, source: link.source, target: link.target });
                
                // Add edge to node edge maps
                nodeEdges.get(link.source).push(line);
                nodeEdges.get(link.target).push(line);
            }
        });

        // Selection functions
        function selectNode(nodeName) {
            const mesh = nodeMeshes.get(nodeName);
            if (!mesh) return;
            
            // Add class to node
            addClass(mesh, nodeName);
            
            // Add class to glow if exists
            const glow = nodeMeshes.get(nodeName + '_glow');
            if (glow) addClass(glow, nodeName);
            
            // Add class to neighbors
            const neighbors = nodeNeighbors.get(nodeName) || [];
            neighbors.forEach(neighborName => {
                const neighborMesh = nodeMeshes.get(neighborName);
                if (neighborMesh) addClass(neighborMesh, nodeName);
                
                const neighborGlow = nodeMeshes.get(neighborName + '_glow');
                if (neighborGlow) addClass(neighborGlow, nodeName);
            });
            
            // Add class to connected edges
            const connectedEdges = nodeEdges.get(nodeName) || [];
            connectedEdges.forEach(edge => {
                addClass(edge, nodeName);
            });
        }

        function deselectNode(nodeName) {
            const mesh = nodeMeshes.get(nodeName);
            if (!mesh) return;
            
            // Remove class from node
            removeClass(mesh, nodeName);
            
            // Remove class from glow if exists
            const glow = nodeMeshes.get(nodeName + '_glow');
            if (glow) removeClass(glow, nodeName);
            
            // Remove class from neighbors
            const neighbors = nodeNeighbors.get(nodeName) || [];
            neighbors.forEach(neighborName => {
                const neighborMesh = nodeMeshes.get(neighborName);
                if (neighborMesh) removeClass(neighborMesh, nodeName);
                
                const neighborGlow = nodeMeshes.get(neighborName + '_glow');
                if (neighborGlow) removeClass(neighborGlow, nodeName);
            });
            
            // Remove class from connected edges
            const connectedEdges = nodeEdges.get(nodeName) || [];
            connectedEdges.forEach(edge => {
                removeClass(edge, nodeName);
            });
        }

        function toggleNodeSelection(nodeName) {
            const mesh = nodeMeshes.get(nodeName);
            if (!mesh) return;
            
            if (hasClass(mesh, nodeName)) {
                deselectNode(nodeName);
            } else {
                selectNode(nodeName);
            }
        }

        // update colors based on selection state
        // Update colors based on selection state
        function updateColors() {
            nodeObjects.forEach(mesh => {
                const hasClasses = mesh.userData.classes && mesh.userData.classes.size > 0;
                const nodeName = mesh.userData.name;
                
                if (hasClasses) {
                    mesh.material.color.setHex(SELECTED_COLOR);
                    createGlow(nodeName); // Create glow if selected
                } else {
                    mesh.material.color.setHex(mesh.userData.originalColor);
                    removeGlow(nodeName); // Remove glow if not selected
                }
            });
            
            // Update existing glow colors and properties
            nodeMeshes.forEach((mesh, key) => {
                if (key.includes('_glow')) {
                    const hasClasses = mesh.userData.classes && mesh.userData.classes.size > 0;
                    if (hasClasses) {
                        mesh.material.color.setHex(SELECTED_GLOW_COLOR);
                        mesh.material.transparent = true;
                        mesh.material.opacity = GLOW_OPACITY;
                        mesh.material.blending = THREE.AdditiveBlending;
                    }
                }
            });
            
            // Update edges
            edgeLines.forEach(({ line }) => {
                const hasClasses = line.userData.classes && line.userData.classes.size > 0;
                if (hasClasses) {
                    line.material.color.setHex(SELECTED_COLOR);
                    line.material.transparent = true;
                    line.material.opacity = EDGE_OPACITY;
                    line.material.blending = THREE.AdditiveBlending;
                } else {
                    line.material.color.setHex(line.userData.originalColor);
                }
            });
        }



        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * PARTICLE_SPREAD;
            positions[i * 3 + 1] = (Math.random() - 0.5) * PARTICLE_SPREAD;
            positions[i * 3 + 2] = (Math.random() - 0.5) * PARTICLE_SPREAD;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: PARTICLE_COLOR,
            size: PARTICLE_SIZE,
            transparent: true,
            opacity: PARTICLE_OPACITY,
            blending: THREE.AdditiveBlending
        });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        let stepSize = INITIAL_STEP_SIZE;
        let currentIteration = 0;

        function applyForces() {
            if (currentIteration >= SIMULATION_ITERATIONS) return;
            currentIteration++;

            nodesData.forEach(node => {
                const vel = nodeVelocities.get(node.name);
                vel.x = 0;
                vel.y = 0;
                vel.z = 0;
            });

            linksData.forEach(link => {
                const pos1 = nodePositions.get(link.source);
                const pos2 = nodePositions.get(link.target);

                if (!pos1 || !pos2) return;

                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const dz = pos2.z - pos1.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.01;

                const force = distance * ATTRACTION_STRENGTH;
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                const vel1 = nodeVelocities.get(link.source);
                const vel2 = nodeVelocities.get(link.target);

                vel1.x += fx;
                vel1.y += fy;
                vel1.z += fz;
                vel2.x -= fx;
                vel2.y -= fy;
                vel2.z -= fz;
            });

            const nodeNames = Array.from(nodePositions.keys());
            for (let i = 0; i < nodeNames.length; i++) {
                for (let j = i + 1; j < nodeNames.length; j++) {
                    const name1 = nodeNames[i];
                    const name2 = nodeNames[j];
                    const pos1 = nodePositions.get(name1);
                    const pos2 = nodePositions.get(name2);

                    const dx = pos2.x - pos1.x;
                    const dy = pos2.y - pos1.y;
                    const dz = pos2.z - pos1.z;
                    const distSq = dx*dx + dy*dy + dz*dz || 0.01;
                    const dist = Math.sqrt(distSq);

                    const force = REPULSION_STRENGTH / distSq;
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    const fz = (dz / dist) * force;

                    const vel1 = nodeVelocities.get(name1);
                    const vel2 = nodeVelocities.get(name2);

                    vel1.x -= fx;
                    vel1.y -= fy;
                    vel1.z -= fz;
                    vel2.x += fx;
                    vel2.y += fy;
                    vel2.z += fz;
                }
            }

            nodesData.forEach(node => {
                const pos = nodePositions.get(node.name);
                const vel = nodeVelocities.get(node.name);

                if (!pos || !vel) return;

                const dx = SPHERE_CENTER.x - pos.x;
                const dy = SPHERE_CENTER.y - pos.y;
                const dz = SPHERE_CENTER.z - pos.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.01;

                const force = distance * CENTERING_STRENGTH;
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;

                vel.x += fx;
                vel.y += fy;
                vel.z += fz;
            });

            nodesData.forEach(node => {
                const pos = nodePositions.get(node.name);
                const vel = nodeVelocities.get(node.name);

                pos.x += vel.x * stepSize;
                pos.y += vel.y * stepSize;
                pos.z += vel.z * stepSize;

                const maxDist = SPHERE_RADIUS * 1.2;
                const distFromCenter = Math.sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z);
                if (distFromCenter > maxDist) {
                    const scale = maxDist / distFromCenter;
                    pos.x *= scale;
                    pos.y *= scale;
                    pos.z *= scale;
                }

                const mesh = nodeMeshes.get(node.name);
                mesh.position.set(pos.x, pos.y, pos.z);

                const glow = nodeMeshes.get(node.name + '_glow');
                if (glow) {
                    glow.position.set(pos.x, pos.y, pos.z);
                }
            });

            edgeLines.forEach(({ line, source, target }) => {
                const sourcePos = nodePositions.get(source);
                const targetPos = nodePositions.get(target);
                const posArray = line.geometry.attributes.position.array;
                posArray[0] = sourcePos.x;
                posArray[1] = sourcePos.y;
                posArray[2] = sourcePos.z;
                posArray[3] = targetPos.x;
                posArray[4] = targetPos.y;
                posArray[5] = targetPos.z;
                line.geometry.attributes.position.needsUpdate = true;
            });

            stepSize *= COOLING_RATE;
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const infoDiv = document.getElementById('info-content');

        function onMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeObjects);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                const data = obj.userData;
                infoDiv.textContent = `${data.name} â€¢ ${data.group}`;
                canvas.style.cursor = 'pointer';
            } else {
                infoDiv.textContent = 'Drag to rotate â€¢ Scroll to zoom';
                canvas.style.cursor = 'grab';
            }
        }

        function onClick(event) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeObjects);

            if (intersects.length > 0) {
                const nodeName = intersects[0].object.userData.name;
                toggleNodeSelection(nodeName);
            }
        }

        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('click', onClick);
        canvas.addEventListener('mousedown', () => { canvas.style.cursor = 'grabbing'; });
        canvas.addEventListener('mouseup', () => { canvas.style.cursor = 'grab'; });

        function animate() {
            requestAnimationFrame(animate);

            applyForces();
            updateColors();

            const time = Date.now() * NODE_PULSE_SPEED;
            nodeObjects.forEach((obj, i) => {
                const scale = 1 + Math.sin(time + i * 0.1) * NODE_PULSE_AMPLITUDE;
                obj.scale.setScalar(scale);
            });

            particles.rotation.y += PARTICLE_ROTATION_SPEED_Y;
            particles.rotation.x += PARTICLE_ROTATION_SPEED_X;

            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize pre-selected nodes
        INITIAL_SELECTED_NODES.forEach(nodeName => {
            selectNode(nodeName);
        });

        animate();
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initNetwork);
    } else {
        initNetwork();
    }
</script>

<style>
    #viz-container {
        height: fit-content;
        max-height: 100%;
        width: 90vw;
        margin: 1rem auto; 
        position: relative;
        background: #1E1E1E;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 0.25rem 1.25rem rgba(255, 255, 255, 0.1);
    }

    #network-canvas {
        width: 90vw !important;
        height: auto !important;
        aspect-ratio: 5 / 5 !important;
        display: block;
        cursor: grab;
    }

    @media screen and (min-width: 636px) {
        #viz-container {
            width: fit-content;
            max-width: 100%;
            height: 70vh;
            margin: 2rem auto;
        }
        #network-canvas {
            width: auto !important;
            height: 70vh !important;
            aspect-ratio: 5 / 4 !important;
        }
    }

    #network-canvas:active {
        cursor: grabbing;
    }

    #node-info {
        position: absolute;
        bottom: 20px;
        left: 20px;
        right: 20px;
        background: rgba(217, 119, 87, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(217, 119, 87, 0.3);
        border-radius: 8px;
        padding: 12px 16px;
        font-family: 'IM FELL English', serif;
        pointer-events: none;
    }

    #info-content {
        color: var(--dark-text);
        font-size: 13px;
        text-align: center;
        letter-spacing: 0.5px;
    }
</style>
