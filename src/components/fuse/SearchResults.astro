---
export interface Props {
  dataUrl?: string;
  searchData?: any[];
  searchTitle?: string;
  searchKeys?: Array<{ name: string; weight?: number }>;
  linkPrefix?: string;
  authorField?: string;
  titleField?: string;
  dateField?: string;
  slugField?: string;
}

const { 
  dataUrl,
  searchData,
  searchTitle = "Search Results",
  searchKeys = [
    { name: "title", weight: 1 },
    { name: "description", weight: 0.75 }
  ],
  linkPrefix = "/blog/",
  authorField = "author",
  titleField = "title", 
  dateField = "date",
  slugField = "slug"
} = Astro.props;
---

<div class="search-results-container">
  <p id="searchReadout" class="search-readout"></p>
  <section aria-label="Search Results">
    <ul id="searchResults" class="search-results-list"></ul>
  </section>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js" is:inline></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/7.0.0/fuse.min.js" is:inline></script>

<script is:inline define:vars={{ dataUrl, searchData, searchTitle, searchKeys, linkPrefix, authorField, titleField, dateField, slugField }}>
  document.addEventListener("DOMContentLoaded", () => {
    let SEARCH_DATA = searchData; // Use passed data if available
    let FUSE_INSTANCE;
    const FUSE_OPTIONS = {
      includeScore: true,
      shouldSort: true,
      threshold: 0.5,
      keys: searchKeys
    };

    const SPINNER = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="#000000" viewBox="0 0 256 256" id="spinner"><path d="M236,128a108,108,0,0,1-216,0c0-42.52,24.73-81.34,63-98.9A12,12,0,1,1,93,50.91C63.24,64.57,44,94.83,44,128a84,84,0,0,0,168,0c0-33.17-19.24-63.43-49-77.09A12,12,0,1,1,173,29.1C211.27,46.66,236,85.48,236,128Z"></path><style>#spinner{animation: spin 1s linear infinite;}@keyframes spin{100%{transform: rotate(360deg);}}</style></svg>`;

    const searchReadout = document.querySelector("#searchReadout");
    const resultsList = document.querySelector("#searchResults");

    function updateDocumentTitle(searchQuery) {
      document.title = searchQuery ? `Search results for "${searchQuery}"` : searchTitle;
    }

    function updateSearchReadout(searchQuery) {
      if (searchReadout) {
        searchReadout.textContent = searchQuery ? `Search results for "${searchQuery}"` : "";
      }
    }

    function generateSearchList(results) {
      return results
        .map((r) => {
          const item = r.item;
          const title = item[titleField] || item.title || "Untitled";
          const date = item[dateField] || item.date;
          const slug = item[slugField] || item.slug;
          const author = item[authorField] || item.author;
          const number = item.number;
          
          const dateAsDate = new Date(date);
          const authorDisplay = author ? ` by ${author}` : "";
          const numberDisplay = number ? ` #${number}` : "";
          
          // Check if slug is a full URL or just a path
          const fullUrl = slug && slug.startsWith('http') ? slug : `${linkPrefix}${slug}/`;
          
          return `<li>
            <time datetime="${dateAsDate.toISOString()}">
              ${dateAsDate.toLocaleDateString("en-us", {
                year: "numeric",
                month: "short",
                day: "numeric",
              })}
            </time>
            <a href="${fullUrl}" target="_blank">${title}${numberDisplay}${authorDisplay}</a>
          </li>`;
        })
        .join("");
    }

    async function fetchSearchResults(searchQuery) {
      if (!searchQuery || searchQuery.length === 0) {
        resultsList.innerHTML = "";
        updateSearchReadout("");
        updateDocumentTitle("");
        return;
      }
      
      resultsList.innerHTML = SPINNER;
      
      // Load search data if not available
      if (!SEARCH_DATA && dataUrl) {
        try {
          const res = await fetch(dataUrl);
          if (!res.ok) {
            throw new Error("Something went wrong…please try again");
          }
          const data = await res.json();
          SEARCH_DATA = data;
        } catch (e) {
          console.error(e);
          resultsList.innerHTML = "Error loading search data.";
          return;
        }
      }
      
      // Create Fuse instance if not exists
      if (SEARCH_DATA && !FUSE_INSTANCE) {
        FUSE_INSTANCE = new Fuse(SEARCH_DATA, FUSE_OPTIONS);
      }
      
      if (!FUSE_INSTANCE) {
        resultsList.innerHTML = "Search not available.";
        return;
      }
      
      // Perform search
      const searchResult = FUSE_INSTANCE.search(searchQuery);
      resultsList.innerHTML = searchResult.length > 0 
        ? generateSearchList(searchResult) 
        : "No results found…";
      
      updateSearchReadout(searchQuery);
      updateDocumentTitle(searchQuery);
    }

    let hasSearched = false; // Track if search has been performed
    let lastSearchQuery = "";

    function updateSearchReadout(searchQuery) {
      if (searchReadout && hasSearched) {
        if (searchQuery) {
          searchReadout.innerHTML = `You searched for "<strong>${searchQuery}</strong>"`;
        } else {
          searchReadout.textContent = "";
        }
      }
    }

    async function fetchSearchResults(searchQuery, isFormSubmission = false) {
      // Only show results if it's a form submission or we've already searched
      if (!isFormSubmission && !hasSearched) {
        return;
      }

      if (!searchQuery || searchQuery.length === 0) {
        resultsList.innerHTML = "";
        updateSearchReadout("");
        updateDocumentTitle("");
        return;
      }
      
      hasSearched = true;
      lastSearchQuery = searchQuery;
      resultsList.innerHTML = SPINNER;
      
      // Load search data if not available
      if (!SEARCH_DATA && dataUrl) {
        try {
          const res = await fetch(dataUrl);
          if (!res.ok) {
            throw new Error("Something went wrong…please try again");
          }
          const data = await res.json();
          SEARCH_DATA = data;
        } catch (e) {
          console.error(e);
          resultsList.innerHTML = "Error loading search data.";
          return;
        }
      }
      
      // Create Fuse instance if not exists
      if (SEARCH_DATA && !FUSE_INSTANCE) {
        FUSE_INSTANCE = new Fuse(SEARCH_DATA, FUSE_OPTIONS);
      }
      
      if (!FUSE_INSTANCE) {
        resultsList.innerHTML = "Search not available.";
        return;
      }
      
      // Perform search
      const searchResult = FUSE_INSTANCE.search(searchQuery);
      
      if (searchResult.length > 0) {
        resultsList.innerHTML = generateSearchList(searchResult);
        updateSearchReadout(searchQuery);
      } else {
        resultsList.innerHTML = "No results found…";
        updateSearchReadout(searchQuery);
      }
      
      updateDocumentTitle(searchQuery);
    }

    // Check if we came from SearchWidget (has URL params on page load)
    const initialUrlParams = DOMPurify.sanitize(
      new URLSearchParams(window.location.search).get("q") || ""
    );
    
    // If there are URL params on page load, treat as form submission
    if (initialUrlParams) {
      fetchSearchResults(initialUrlParams, true);
    }

    // Listen for search updates from SearchInput component
    window.addEventListener('searchUpdated', (e) => {
      fetchSearchResults(e.detail.query, e.detail.isFormSubmission || false);
    });

    // Listen for URL changes (back/forward buttons)
    window.addEventListener('popstate', () => {
      const urlParams = DOMPurify.sanitize(
        new URLSearchParams(window.location.search).get("q") || ""
      );
      // Only show results if we've searched before
      if (hasSearched) {
        fetchSearchResults(urlParams, false);
      }
    });
  });
</script>

<style>
  .search-results-container {
    margin-top: 2rem;
  }

  .search-readout {
    font-weight: bold;
    margin-bottom: 1rem;
    color: var(--text-color);
  }

  .search-suggestion {
    margin-bottom: 1rem;
  }

  .search-suggestion p {
    margin: 0.25rem 0;
    color: var(--text-color);
  }

  .search-suggestion p:first-child {
    font-weight: bold;
  }

  .search-again-link {
    color: var(--link-color);
    text-decoration: underline;
    cursor: pointer;
  }

  .search-again-link:hover {
    color: var(--hover-color);
  }

  .search-results-list {
    list-style-type: none;
    padding: 0;
  }

  .search-results-list li {
    display: flex;
    margin-bottom: 1rem;
    padding: 1rem;
    border: var(--image-border);
    border-radius: 4px;
  }

  .search-results-list li time {
    flex: 0 0 130px;
    font-style: italic;
    color: #595959;
    margin-right: 1rem;
  }

  .search-results-list li a {
    color: var(--link-color);
    text-decoration: none;
  }

  .search-results-list li a:visited {
    color: #8e32dc;
  }

  .search-results-list li a:hover {
    text-decoration: underline;
  }
</style>