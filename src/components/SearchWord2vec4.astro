---
const { word2vecData, textData, textFields } = Astro.props;
const searchTerm = Astro.url.searchParams.get('searchTerm')?.trim() || '';

// Get similar words for the search term
const wordMatch = word2vecData.find(item => item.word === searchTerm);
const similarWords = wordMatch ? wordMatch.similar.slice(0,20) : [];

// Process ALL matching entries but only render first 10
const allMatchingEntries = searchTerm ? textData.filter((entry) => {
    const text = entry[textFields.text];
    const paragraphs = text.split(/\n{2,}/).map(p => p.replace(/\n/g, ' ').trim());
    return paragraphs.some(p => p.toLowerCase().includes(searchTerm.toLowerCase()));
}) : [];

function highlightTerms(paragraph: string, keyword: string, similar: string[]): string {
    let result = paragraph;
    
    // First highlight similar words
    similar.forEach(word => {
        const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const wordRegex = new RegExp(`\\b(${escapedWord}\\w*)`, 'gi');
        result = result.replace(wordRegex, '<mark style="background-color:transparent; color:var(--highlight-color);">$1</mark>');
    });
    
    // Then highlight keyword (will override similar word highlighting)
    if (keyword) {
        const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const keywordRegex = new RegExp(`\\b(${escapedKeyword}\\w*)`, 'gi');
        result = result.replace(keywordRegex, '<mark style="background-color:transparent; color:var(--hover-color);">$1</mark>');
    }
    
    return result;
}

function getMatchingParagraphs(text: string, keyword: string, similar: string[]): Array<{ index: number, html: string }> {
    if (!keyword) return [];
    
    return text
        .split(/\n{2,}/)
        .map(p => p.replace(/\n/g, ' ').trim())
        .filter(p => {
            const lowerP = p.toLowerCase();
            const hasKeyword = keyword && lowerP.includes(keyword.toLowerCase());
            return hasKeyword;
        })
        .map((p, i) => ({ index: i, html: highlightTerms(p, keyword, similar) }));
}
---

<div class="autocomplete">
  <form method="GET" class="search-bar">
    <input
      type="text"
      name="searchTerm"
      placeholder="Find a word..."
      value={searchTerm}
    />
    <button type="submit" class="search-button">Search</button>
  </form>

  <div class="dropdown">
    <div class="dropdown-menu">
      <div class="dropdown-content results"></div>
    </div>
  </div>
</div>

{searchTerm && (
  <div class="search-results">
    <p><strong>Keyword:</strong> {searchTerm}</p>
    {similarWords.length > 0 && (
      <p><strong>Vectors:</strong> {similarWords.join(', ')}</p>
    )}
  </div>
)}

<ol id="results-list">
  {allMatchingEntries.slice(0, 10).map((entry, index) => {
    const matches = getMatchingParagraphs(entry[textFields.text], searchTerm, similarWords);
    return (
      <li>
        <details>
          <summary>
            <span class="entry-label">
              <strong>{entry[textFields.author]},</strong>
              <a href={entry[textFields.url]} target="_blank">{entry[textFields.title]}</a> ({entry[textFields.date]})
            </span>
            <span class="arrow"></span>
          </summary>
          <ul>
            {matches.map(match => (
              <li class="paragraph-match">
                <p><span set:html={match.html} /></p>
              </li>
            ))}
          </ul>
        </details>
      </li>
    );
  })}
</ol>

{allMatchingEntries.length > 10 && (
  <div class="pagination">
    <button id="prev-btn" disabled>⟨⟨</button>
    <span id="page-info">Page 1 of {Math.ceil(allMatchingEntries.length / 10)}</span>
    <button id="next-btn">⟩⟩</button>
  </div>
)}

<script define:vars={{ word2vecData, allMatchingEntries, searchTerm, similarWords, textFields }}>
  let currentPage = 1;
  const perPage = 10;
  const totalPages = Math.ceil(allMatchingEntries.length / perPage);
  
  function highlightTerms(paragraph, keyword, similar) {
    let result = paragraph;
    
    similar.forEach(word => {
      const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const wordRegex = new RegExp(`\\b(${escapedWord}\\w*)`, 'gi');
      result = result.replace(wordRegex, '<mark style="background-color:transparent; color:var(--highlight-color);">$1</mark>');
    });
    
    if (keyword) {
      const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const keywordRegex = new RegExp(`\\b(${escapedKeyword}\\w*)`, 'gi');
      result = result.replace(keywordRegex, '<mark style="background-color:transparent; color:var(--hover-color);">$1</mark>');
    }
    
    return result;
  }
  
  function getMatchingParagraphs(text, keyword, similar) {
    if (!keyword) return [];
    
    return text
      .split(/\n{2,}/)
      .map(p => p.replace(/\n/g, ' ').trim())
      .filter(p => p.toLowerCase().includes(keyword.toLowerCase()))
      .map((p, i) => ({ index: i, html: highlightTerms(p, keyword, similar) }));
  }
  
  function renderPage(page) {
    const startIndex = (page - 1) * perPage;
    const endIndex = startIndex + perPage;
    const pageEntries = allMatchingEntries.slice(startIndex, endIndex);
    
    const resultsList = document.getElementById('results-list');
    resultsList.innerHTML = '';
    resultsList.setAttribute('start', startIndex + 1);
    
    pageEntries.forEach(entry => {
      const matches = getMatchingParagraphs(entry[textFields.text], searchTerm, similarWords);
      
      const li = document.createElement('li');
      li.innerHTML = `
      <style>
      #results-list details summary { cursor: pointer; display: flex; align-items: center; justify-content: space-between; font-weight: bold; font-size: 1.2rem; padding: 0 0 0.5rem 0; }
      #results-list summary::-webkit-details-marker { display: none; }
      #results-list .arrow { display: inline-block; transition: transform 0.2s; border: solid var(--light-text); border-width: 0 2px 2px 0; padding: 3px; margin-left: 4px; transform: rotate(-45deg); }
      #results-list details[open] .arrow { transform: rotate(45deg); }
      html.dark #results-list .arrow { border-color: var(--dark-text); }
      #results-list .paragraph-match { list-style: square;}
      #results-list .paragraph-match p { margin: 0 0 0.5rem 0; font-size: 1.1rem;}
      #results-list .paragraph-match::marker { color: var(--hover-color);}
      </style>
        <details>
          <summary>
            <span class="entry-label">
              <strong>${entry[textFields.author]},</strong>
              <a href="${entry[textFields.url]}" target="_blank">${entry[textFields.title]}</a> (${entry[textFields.date]})
            </span>
            <span class="arrow"></span>
          </summary>
          <ul>
            ${matches.map(match => `
              <li class="paragraph-match">
                <p><span>${match.html}</span></p>
              </li>
            `).join('')}
          </ul>
        </details>
      `;
      resultsList.appendChild(li);
    });
    
    // Update pagination
    document.getElementById('prev-btn').disabled = page === 1;
    document.getElementById('next-btn').disabled = page === totalPages;
    document.getElementById('page-info').textContent = `Page ${page} of ${totalPages}`;
  }

  
  // Pagination event listeners
  document.getElementById('prev-btn')?.addEventListener('click', () => {
    if (currentPage > 1) {
      currentPage--;
      renderPage(currentPage);
    }
  });
  
  document.getElementById('next-btn')?.addEventListener('click', () => {
    if (currentPage < totalPages) {
      currentPage++;
      renderPage(currentPage);
    }
  });

  // Autocomplete functionality
  const input = document.querySelector('input[name="searchTerm"]');
  const dropdown = document.querySelector('.dropdown');
  const results = document.querySelector('.results');
  const form = document.querySelector('.search-bar');

  form.addEventListener('submit', (e) => {
    input.value = input.value.trim().toLowerCase();
  });

  let timeout;
  input.addEventListener('input', (e) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      const term = e.target.value.trim().toLowerCase();
      
      if (!term) {
        dropdown.classList.remove('is-active');
        return;
      }

      const matches = word2vecData.filter(d => d.word.toLowerCase().includes(term)).slice(0, 10);
      
      if (matches.length > 0) {
        results.innerHTML = `
          <style>
            .dropdown-item { display: block; padding: 0 0 0 0.5rem; font-size: 1rem; text-decoration: none; color: var(--light-text); }
            .dropdown-item:hover { color: var(--hover-color); }
          </style>
          ${matches.map(match => 
            `<a href="?searchTerm=${match.word}" class="dropdown-item">${match.word}</a>`
          ).join('')}`;
        dropdown.classList.add('is-active');
      } else {
        dropdown.classList.remove('is-active');
      }
    }, 300);
  });

</script>

<style>
  .autocomplete {
    position: relative;
    width: 100%;
    margin-bottom: 1rem;
  }
  
  .search-bar {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .search-bar input {
    flex: 1;
    padding: 0.5rem;
    font-size: 1rem;
    font-family: 'IM Fell English', serif;
    box-sizing: border-box;
  }

  .search-bar button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    cursor: pointer;
    font-family: 'IM Fell English', serif;
  }

  .search-button {
    border: var(--image-border);
    transition: background-color 0.3s ease, color 0.3s ease;
  }

  .search-button:hover {
    background-color: var(--hover-color);
    color: white;
  }

  .dropdown {
    position: absolute;
    width: 100%;
    top: 100%;
    left: 0;
    z-index: 10;
  }
  
  .dropdown.is-active {
    display: block;
  }
  
  .dropdown-content {
    display: flex;
    flex-direction: column;
    background-color: #f5f5f5;
    border: var(--image-border);
  }
  
  .dropdown-menu {
    width: 100%;
    max-height: 20rem;
    overflow-y: auto;
  }
  
  .search-results {
    margin: 1rem 0;
  }
  
  ol {
    padding-left: 1rem;
    margin: 0;
  }
  
  details summary {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-weight: bold;
    font-size: 1.2rem;
    padding: 0 0 0.5rem 0;
  }

  summary::-webkit-details-marker {
    display: none;
  }

  .arrow {
    display: inline-block;
    transition: transform 0.2s;
    border: solid var(--light-text);
    border-width: 0 2px 2px 0;
    padding: 3px;
    margin-left: 4px;
    transform: rotate(-45deg);
  }

  details[open] .arrow {
    transform: rotate(45deg);
  }

  html.dark .arrow {
    border-color: var(--dark-text);
  }

  ul {
    margin: 0 0 1rem 0;
    padding-left: 1.2rem;
    list-style-type: disc;
  }

  .paragraph-match {
    list-style: square;
  }

  .paragraph-match p {
    margin: 0 0 0.5rem 0;
    font-size: 1.1rem;
  }

  .paragraph-match::marker {
    color: var(--hover-color);
  }

  mark {
    background-color: transparent;
    font-weight: bold;
  }

  .pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin: 1rem 0 2rem 0;
  }
  
  .pagination button {
    padding: 0.5rem 1rem;
    font-size: 1.2rem;
    cursor: pointer;
    font-family: 'IM Fell English', serif;
    border: var(--image-border);
    transition: background-color 0.3s ease, color 0.3s ease;
    background-color: ButtonFace;
  }

  .pagination button:hover:not(:disabled) {
    background-color: var(--hover-color);
    color: white;
  }

  .pagination button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  html.dark .pagination button {
    color: var(--light-text);
  }
</style>
