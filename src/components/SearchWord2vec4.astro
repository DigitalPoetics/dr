---
const { word2vecData, textData, textFields } = Astro.props;
const searchTerm = Astro.url.searchParams.get('searchTerm')?.trim() || '';
const page = parseInt(Astro.url.searchParams.get('page') || '1');
const perPage = 10;

// Get similar words for the search term
const wordMatch = word2vecData.find(item => item.word === searchTerm);
const similarWords = wordMatch ? wordMatch.similar.slice(0,20) : [];

// Filter entries that have matches first
const entriesWithMatches = textData.filter((entry) => {
    if (!searchTerm) return false;
    const text = entry[textFields.text];
    const paragraphs = text.split(/\n{2,}/).map(p => p.replace(/\n/g, ' ').trim());
    return paragraphs.some(p => p.toLowerCase().includes(searchTerm.toLowerCase()));
});

// Paginate the filtered entries
const startIndex = (page - 1) * perPage;
const endIndex = startIndex + perPage;
const paginatedEntries = entriesWithMatches.slice(startIndex, endIndex);
const totalPages = Math.ceil(entriesWithMatches.length / perPage);

function highlightTerms(paragraph: string, keyword: string, similar: string[]): string {
    let result = paragraph;
  
    // First highlight similar words
    similar.forEach(word => {
        const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const wordRegex = new RegExp(`\\b(${escapedWord}\\w*)`, 'gi');
        result = result.replace(wordRegex, '<mark style="background-color:transparent; color:var(--highlight-color);">$1</mark>');
    });
    
    // Then highlight keyword (will override similar word highlighting)
    if (keyword) {
        const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const keywordRegex = new RegExp(`\\b(${escapedKeyword}\\w*)`, 'gi');
        result = result.replace(keywordRegex, '<mark style="background-color:transparent; color:var(--hover-color);">$1</mark>');
    }
    
    return result;
}

function getMatchingParagraphs(text: string, keyword: string, similar: string[]): Array<{ index: number, html: string }> {
    if (!keyword) return [];
    
    return text
        .split(/\n{2,}/)
        .map(p => p.replace(/\n/g, ' ').trim())
        .filter(p => {
            const lowerP = p.toLowerCase();
            const hasKeyword = keyword && lowerP.includes(keyword.toLowerCase());
            return hasKeyword; // Only return paragraphs that contain the keyword
        })
        .map((p, i) => ({ index: i, html: highlightTerms(p, keyword, similar) }));
}
---

<div class="autocomplete">
  <form method="GET" class="search-bar">
    <input
      type="text"
      name="searchTerm"
      placeholder="Find a word..."
      value={searchTerm}
    />
    <button type="submit" class="search-button">Search</button>
  </form>

  <div class="dropdown">
    <div class="dropdown-menu">
      <div class="dropdown-content results"></div>
    </div>
  </div>
</div>

{searchTerm && (
  <div class="search-results">
    <p><strong>Keyword:</strong> {searchTerm}</p>
    {similarWords.length > 0 && (
      <p><strong>Vectors:</strong> {similarWords.join(', ')}</p>
    )}
  </div>
)}

<ol start={startIndex + 1}>
  {paginatedEntries.map((entry) => {
    const matches = getMatchingParagraphs(entry[textFields.text], searchTerm, similarWords);
    return (
      <li>
        <details>
          <summary>
            <span class="entry-label">
              <strong>{entry[textFields.author]},</strong>
              <a href={entry[textFields.url]} target="_blank">{entry[textFields.title]}</a> ({entry[textFields.date]})
            </span>
            <span class="arrow"></span>
          </summary>
          <ul>
            {matches.map(match => (
              <li class="paragraph-match">
                <p><span set:html={match.html} /></p>
              </li>
            ))}
          </ul>
        </details>
      </li>
    );
  })}
</ol>

{totalPages > 1 && (
  <div class="pagination">
    {page > 1 && (
      <a href={`?searchTerm=${searchTerm}&page=${page - 1}`}>⟨⟨</a>
    )}
    <span>Page {page} of {totalPages}</span>
    {page < totalPages && (
      <a href={`?searchTerm=${searchTerm}&page=${page + 1}`}>⟩⟩</a>
    )}
  </div>
)}

<script define:vars={{ word2vecData }}>
  const input = document.querySelector('input[name="searchTerm"]');
  const dropdown = document.querySelector('.dropdown');
  const results = document.querySelector('.results');
  const form = document.querySelector('.search-bar');

  form.addEventListener('submit', (e) => {
    input.value = input.value.trim().toLowerCase();
  });
  
  input.addEventListener('input', (e) => {
    const term = e.target.value.trim().toLowerCase();
    
    if (!term) {
      dropdown.classList.remove('is-active');
      return;
    }

    const matches = word2vecData.filter(d => d.word.toLowerCase().includes(term));
    
    if (matches.length > 0) {
      results.innerHTML = `
        <style>
          .dropdown-item { display: block; padding: 0 0 0 0.5rem; font-size: 1rem; text-decoration: none; color: var(--light-text); }
          .dropdown-item:hover { color: var(--hover-color); }
        </style>
        ${matches.map(match => 
          `<a href="?searchTerm=${match.word}" class="dropdown-item">${match.word}</a>`
        ).join('')}`;
      dropdown.classList.add('is-active');
    } else {
      dropdown.classList.remove('is-active');
    }
  });
</script>

<style>
  .autocomplete {
    position: relative;
    width: 100%;
    margin-bottom: 1rem;
  }
  
  .search-bar {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .search-bar input {
    flex: 1;
    padding: 0.5rem;
    font-size: 1rem;
    font-family: 'IM Fell English', serif;
    box-sizing: border-box;
  }

  .search-bar button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    cursor: pointer;
    font-family: 'IM Fell English', serif;
  }

  .search-button {
    border: var(--image-border);
    transition: background-color 0.3s ease, color 0.3s ease;
  }

  .search-button:hover {
    background-color: var(--hover-color);
    color: white;
  }

  .dropdown {
    position: absolute;
    width: 100%;
    top: 100%;
    left: 0;
    z-index: 10;
  }
  
  .dropdown.is-active {
    display: block;
  }
  
  .dropdown-content {
    display: flex;
    flex-direction: column;
    background-color: #f5f5f5;
    border: var(--image-border);
  }
  
  .dropdown-menu {
    width: 100%;
    max-height: 20rem;
    overflow-y: auto;
  }
  
  .search-results {
    margin: 1rem 0;
  }
  
  ol {
    padding-left: 1rem;
    margin: 0;
  }
  
  details summary {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-weight: bold;
    font-size: 1.2rem;
    padding: 0 0 0.5rem 0;
  }

  summary::-webkit-details-marker {
    display: none;
  }

  .arrow {
    display: inline-block;
    transition: transform 0.2s;
    border: solid var(--light-text);
    border-width: 0 2px 2px 0;
    padding: 3px;
    margin-left: 4px;
    transform: rotate(-45deg);
  }

  details[open] .arrow {
    transform: rotate(45deg);
  }

  html.dark .arrow {
    border-color: var(--dark-text);
  }

  ul {
    margin: 0 0 1rem 0;
    padding-left: 1.2rem;
    list-style-type: disc;
  }

  .paragraph-match {
    list-style: square;
  }

  .paragraph-match p {
    margin: 0 0 0.5rem 0;
    font-size: 1.1rem;
  }

  .paragraph-match::marker {
    color: var(--hover-color);
  }

  mark {
    background-color: transparent;
    font-weight: bold;
  }

  .pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin: 1rem 0 2rem 0;
  }
  
  .pagination a {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    font-family: 'IM Fell English', serif;
    border: var(--image-border);
    transition: background-color 0.3s ease, color 0.3s ease;
    text-decoration: none;
    background-color: ButtonFace;
  }

  .pagination a:hover {
    background-color: var(--hover-color);
    color: white;
  }

  html.dark .pagination a {
    color: var(--light-text);
  }
</style>
