---
const { word2vecData, textData, textFields } = Astro.props;
const searchTerm = Astro.url.searchParams.get('searchTerm')?.trim() || '';

function tokenizeQuery(query) {
  // Step 1: Clean text (remove non-word chars, single letters, extra spaces)
  let cleaned = query.replace(/\W/g, ' ')                    // Remove non-word chars
                   .replace(/\s+[a-zA-Z]\s+/g, ' ')          // Remove single letters
                   .replace(/\^[a-zA-Z]\s+/g, ' ')           // Remove ^letter patterns
                   .replace(/\s+/g, ' ')                     // Collapse whitespace
                   .toLowerCase()
                   .trim();
  
  // Step 2: Split and filter (length > 3, remove stop words)
  const stopWords = new Set(['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'its', 'may', 'new', 'now', 'old', 'see', 'two', 'who', 'boy', 'did', 'she', 'use', 'way', 'many', 'oil', 'sit', 'set', 'run', 'eat', 'far', 'sea', 'eye', 'ask', 'own', 'say', 'too', 'any', 'try', 'an', 'as', 'at', 'be', 'he', 'if', 'in', 'is', 'it', 'my', 'of', 'on', 'or', 'to', 'up', 'we', 'go', 'no', 'so', 'am', 'by', 'do', 'me']);
  
  return cleaned.split(/\s+/)
                .filter(word => word.length > 3 && !stopWords.has(word));
}


function getQueryMatches(queryTokens) {
  return queryTokens.map(token => {
    const match = word2vecData.find(item => item.word === token);
    return match ? { word: token, similar: match.similar, wordVector: match.wordVector } : null;
  }).filter(Boolean);
}


function calculateQueryVector(matches) {
  if (matches.length === 0) return null;
  
  const vectorLength = matches[0].wordVector.length;
  const sumVector = new Array(vectorLength).fill(0);
  
  matches.forEach(match => {
    match.wordVector.forEach((val, i) => {
      sumVector[i] += val;
    });
  });
  
  return sumVector.map(sum => sum / matches.length);
}


// function calculateSimilarity(docVector, queryVector) {
//   if (!queryVector || !docVector || docVector.length === 0) return 0;
  
//   // Ensure vectors have same length
//   const minLength = Math.min(docVector.length, queryVector.length);
//   if (minLength === 0) return 0;
  
//   const dotProduct = docVector.slice(0, minLength).reduce((sum, val, i) => {
//     const docVal = isNaN(val) ? 0 : val;
//     const queryVal = isNaN(queryVector[i]) ? 0 : queryVector[i];
//     return sum + docVal * queryVal;
//   }, 0);
  
//   const docMag = Math.sqrt(docVector.slice(0, minLength).reduce((sum, val) => {
//     const cleanVal = isNaN(val) ? 0 : val;
//     return sum + cleanVal * cleanVal;
//   }, 0));
  
//   const queryMag = Math.sqrt(queryVector.slice(0, minLength).reduce((sum, val) => {
//     const cleanVal = isNaN(val) ? 0 : val;
//     return sum + cleanVal * cleanVal;
//   }, 0));
  
//   if (docMag === 0 || queryMag === 0) return 0;
  
//   const similarity = dotProduct / (docMag * queryMag);
//   return isNaN(similarity) ? 0 : similarity;
// }


function highlightTerms(paragraph, matches) {
  let result = paragraph;
  
  // First highlight similar words
  matches.forEach(match => {
    match.similar.forEach(word => {
      const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`\\b(${escapedWord})\\b`, 'gi');
    //   result = result.replace(regex, '');
    result = result.replace(regex, '<mark style="background-color:transparent; color:var(--highlight-color);">$1</mark>');

    });
  });
  
  // Then highlight keywords (will override similar word highlighting)
  matches.forEach(match => {
    const escapedKeyword = match.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const keywordRegex = new RegExp(`\\b(${escapedKeyword})\\b`, 'gi');
    // result = result.replace(keywordRegex, '');
    result = result.replace(keywordRegex, '<mark style="background-color:transparent; color:var(--hover-color);">$1</mark>');
  });
  
  return result;
}



function getMatchingParagraphs(text, matches) {
  if (matches.length === 0) return [];
  
  return text
    .split(/\n{2,}/)
    .map(p => p.replace(/\n/g, ' ').trim())
    .filter(p => {
      const lowerP = p.toLowerCase();
    return matches.some(match => lowerP.includes(match.word.toLowerCase()));

    })
    .map((p, i) => ({ index: i, html: highlightTerms(p, matches) }));
}

// Process search if searchTerm exists
let queryMatches = [];
let rankedDocs = [];

if (searchTerm) {
  const queryTokens = tokenizeQuery(searchTerm);
  queryMatches = getQueryMatches(queryTokens);
  
  if (queryMatches.length > 0) {
    // Vector-based search when words are in word2vec data
    const queryVector = calculateQueryVector(queryMatches);
    
    rankedDocs = textData.map(doc => {
      const docVector = doc.docVector;
      if (!docVector) return null;
      
      const dotProduct = docVector.reduce((sum, val, i) => sum + val * queryVector[i], 0);
      const docMag = Math.sqrt(docVector.reduce((sum, val) => sum + val * val, 0));
      const queryMag = Math.sqrt(queryVector.reduce((sum, val) => sum + val * val, 0));
      const similarity = dotProduct / (docMag * queryMag);
      
      const matchingParagraphs = getMatchingParagraphs(doc[textFields.text], queryMatches);
      
      return {
        ...doc,
        similarity: isNaN(similarity) ? 0 : similarity,
        matchingParagraphs
      };
    }).filter(doc => doc && doc.matchingParagraphs.length > 0)
      .sort((a, b) => b.similarity - a.similarity);
  } else {
    // Fallback: simple text search when words not in word2vec data
    rankedDocs = textData.map(doc => {
      const matchingParagraphs = doc[textFields.text]
        .split(/\n{2,}/)
        .map(p => p.replace(/\n/g, ' ').trim())
        .filter(p => {
          const lowerP = p.toLowerCase();
          return queryTokens.some(token => lowerP.includes(token.toLowerCase()));
        })
        .map((p, i) => ({ 
          index: i, 
          html: queryTokens.reduce((result, token) => {
            const regex = new RegExp(`\\b(${token}\\w*)`, 'gi');
            return result.replace(regex, '<mark style="background-color:transparent; color:var(--hover-color);">$1</mark>');
          }, p)
        }));
      
      return matchingParagraphs.length > 0 ? { ...doc, similarity: 0, matchingParagraphs } : null;
    }).filter(Boolean);
  }
}


---

<div class="autocomplete">
  <form method="GET" class="search-bar">
    <input
      type="text"
      name="searchTerm"
      placeholder="Enter search query..."
      value={searchTerm}
    />
    <button type="submit" class="search-button">Search</button>
  </form>
</div>

{searchTerm && queryMatches.length > 0 && (
  <div class="search-results">
    {queryMatches.map(match => (
      <div class="keyword-match">
        <p><strong>Keyword:</strong> {match.word}</p>
        <p><strong>Vectors:</strong> {match.similar.join(', ')}</p>
      </div>
    ))}
  </div>
)}

{rankedDocs.length > 0 && (
  <ol>
    {rankedDocs.map(doc => (
      <li class="document-result">
        <details>
          <summary>
            <span class="entry-label">
              <strong>{doc[textFields.author]},</strong>
              <a href={doc[textFields.url]} target="_blank">{doc[textFields.title]}</a>
              ({doc[textFields.date]})
              {doc.similarity > 0 && (
                <span class="similarity-score">Similarity: {doc.similarity.toFixed(4)}</span>
              )}
            </span>
            <span class="arrow"></span>
          </summary>
          <ul>
            {doc.matchingParagraphs.map(match => (
              <li class="paragraph-match">
                <p><span set:html={match.html} /></p>
              </li>
            ))}
          </ul>
        </details>
      </li>
    ))}
  </ol>
)}

<script define:vars={{ word2vecData }}>
  const form = document.querySelector('.search-bar');
  form.addEventListener('submit', (e) => {
    const input = document.querySelector('input[name="searchTerm"]');
    input.value = input.value.trim().toLowerCase();
  });
</script>

<style>
  .autocomplete {
    position: relative;
    width: 100%;
    margin-bottom: 1rem;
  }
  
  .search-bar {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .search-bar input {
    flex: 1;
    padding: 0.5rem;
    font-size: 1rem;
    font-family: 'IM Fell English', serif;
    box-sizing: border-box;
  }

  .search-button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    cursor: pointer;
    font-family: 'IM Fell English', serif;
    border: var(--image-border);
    transition: background-color 0.3s ease, color 0.3s ease;
  }

  .search-button:hover {
    background-color: var(--hover-color);
    color: white;
  }

  .search-results {
    margin: 1rem 0;
  }

  .keyword-match {
    margin-bottom: 0.5rem;
  }


  .similarity-score {
    font-weight: bold;
    /* color: var(--hover-color); */
    margin-left: 1rem;
  }

  details summary {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-weight: bold;
    font-size: 1.1rem;
    padding: 0 0 0.5rem 0;
  }

  summary::-webkit-details-marker {
    display: none;
  }

  .arrow {
    display: inline-block;
    transition: transform 0.2s;
    border: solid var(--light-text);
    border-width: 0 2px 2px 0;
    padding: 3px;
    margin-left: 4px;
    transform: rotate(-45deg);
  }

  details[open] .arrow {
    transform: rotate(45deg);
  }

  html.dark .arrow {
    border-color: var(--dark-text);
  }

  ul {
    margin: 0 0 1rem 0;
    padding-left: 1.2rem;
    list-style-type: disc;
  }

  .paragraph-match {
    list-style: square;
  }

  .paragraph-match p {
    margin: 0 0 0.5rem 0;
    font-size: 1.1rem;
  }

  .paragraph-match::marker {
    color: var(--hover-color);
  }

  mark {
    background-color: transparent;
    font-weight: bold;
  }

  ol {
    padding-left: 1rem;
    margin: 0;
  }
</style>
