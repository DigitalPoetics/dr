---
const { textData, textFields, word2vecData } = Astro.props;
const searchTerm = Astro.url.searchParams.get('searchTerm')?.trim() || '';

function tokenizeQuery(query) {
  let cleaned = query.replace(/[^\w-]/g, ' ')
                  //  .replace(/\W/g, ' ')
                   .replace(/\s+[a-zA-Z]\s+/g, ' ')
                   .replace(/\^[a-zA-Z]\s+/g, ' ')
                   .replace(/\s+/g, ' ')
                   .toLowerCase()
                   .trim();
  
  const stopWords = new Set(['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'its', 'may', 'new', 'now', 'old', 'see', 'two', 'who', 'boy', 'did', 'she', 'use', 'way', 'many', 'oil', 'sit', 'set', 'run', 'eat', 'far', 'sea', 'eye', 'ask', 'own', 'say', 'too', 'any', 'try', 'an', 'as', 'at', 'be', 'he', 'if', 'in', 'is', 'it', 'my', 'of', 'on', 'or', 'to', 'up', 'we', 'go', 'no', 'so', 'am', 'by', 'do', 'me']);
  
  return cleaned.split(/\s+/).filter(word => word.length > 3 && !stopWords.has(word));
}

function getQueryMatches(queryTokens) {
  return queryTokens.map(token => {
    const match = word2vecData.find(item => item.word === token);
    return match ? { word: token, similar: match.similar, wordVector: match.wordVector } : null;
  }).filter(Boolean);
}

function calculateQueryVector(matches) {
  if (matches.length === 0) return null;
  
  const vectorLength = matches[0].wordVector.length;
  const sumVector = new Array(vectorLength).fill(0);
  
  matches.forEach(match => {
    match.wordVector.forEach((val, i) => {
      sumVector[i] += val;
    });
  });
  
  return sumVector.map(sum => sum / matches.length);
}

// Process ALL matching entries but only render first 10
let allMatchingEntries = [];

if (searchTerm) {
  const queryTokens = tokenizeQuery(searchTerm);
  const queryMatches = getQueryMatches(queryTokens);
  
  if (queryMatches.length > 0) {
    const queryVector = calculateQueryVector(queryMatches);
    
    allMatchingEntries = textData.map(doc => {
      const docVector = doc.docVector;
      if (!docVector) return null;
      
      const dotProduct = docVector.reduce((sum, val, i) => sum + val * queryVector[i], 0);
      const docMag = Math.sqrt(docVector.reduce((sum, val) => sum + val * val, 0));
      const queryMag = Math.sqrt(queryVector.reduce((sum, val) => sum + val * val, 0));
      const similarity = dotProduct / (docMag * queryMag);

      // const text = doc[textFields.text];
      // const paragraphs = text.split(/\n{2,}/).map(p => p.replace(/\n/g, ' ').trim());
      // const hasMatches = paragraphs.some(p => {
      //   const lowerP = p.toLowerCase();
      //   return queryMatches.some(match => lowerP.includes(match.word.toLowerCase()));
      // });

      // Quick text check before expensive paragraph processing
      const text = doc[textFields.text].toLowerCase();
      const hasMatches = queryMatches.some(match => text.includes(match.word.toLowerCase()));
      return hasMatches ? { ...doc, similarity: isNaN(similarity) ? 0 : similarity, queryMatches } : null;
    
      // return { ...doc, similarity: isNaN(similarity) ? 0 : similarity, queryMatches };

    
    }).filter(Boolean).sort((a, b) => b.similarity - a.similarity);


// üîç Log sorted similarity scores
console.log('Sorted similarity scores:');
allMatchingEntries.forEach(entry => {
  console.log(`"${entry[textFields.title]}" ‚Üí ${entry.similarity.toFixed(4)}`);
});

  } else {
    // allMatchingEntries = textData.filter((entry) => {
    //   const text = entry[textFields.text];
    //   const paragraphs = text.split(/\n{2,}/).map(p => p.replace(/\n/g, ' ').trim());
    //   return paragraphs.some(p => {
    //     const lowerP = p.toLowerCase();
    //     return queryTokens.some(token => lowerP.includes(token.toLowerCase()));
    //   });
    // }).map(entry => ({ ...entry, similarity: 0, queryTokens }));

    allMatchingEntries = textData.filter((entry) => {
      const text = entry[textFields.text].toLowerCase();
      return queryTokens.some(token => text.includes(token.toLowerCase()));
    }).map(entry => ({ ...entry, similarity: 0, queryTokens }));

  }
}

function highlightTerms(paragraph: string, matches: any[]): string {
    let result = paragraph;
    
    // First highlight similar words
    matches.forEach(match => {
        if (match.similar) {
            match.similar.forEach(word => {
                const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const wordRegex = new RegExp(`\\b(${escapedWord}\\w*)`, 'gi');
                result = result.replace(wordRegex, '<mark style="background-color:transparent; color:var(--highlight-color);">$1</mark>');
            });
        }
    });
    
    // Then highlight keywords
    matches.forEach(match => {
        const keyword = match.word || match;
        const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const keywordRegex = new RegExp(`\\b(${escapedKeyword}\\w*)`, 'gi');
        result = result.replace(keywordRegex, '<mark style="background-color:transparent; color:var(--hover-color);">$1</mark>');
    });
    
    return result;
}

function getMatchingParagraphs(text: string, matches: any[]): Array<{ index: number, html: string }> {
    if (matches.length === 0) return [];
    
    return text
        .split(/\n{2,}/)
        .map(p => p.replace(/\n/g, ' ').trim())
        .filter(p => {
            const lowerP = p.toLowerCase();
            return matches.some(match => {
                const keyword = match.word || match;
                return lowerP.includes(keyword.toLowerCase());
            });
        })
        .map((p, i) => ({ index: i, html: highlightTerms(p, matches) }));
}
---

<ol id="results-list">
  {allMatchingEntries.slice(0, 10).map((entry, index) => {
    const matches = entry.queryMatches || entry.queryTokens || [];
    const paragraphMatches = getMatchingParagraphs(entry[textFields.text], matches);
    return (
      <li>
        <details>
          <summary>
            <span class="entry-label">
              <strong>{entry[textFields.author]},</strong>
              <a href={entry[textFields.url]} target="_blank">{entry[textFields.title]}</a> ({entry[textFields.date]})
              {entry.similarity > 0 && (
                <span class="similarity-score">Similarity: {entry.similarity.toFixed(4)}</span>
              )}
            </span>
            <span class="arrow"></span>
          </summary>
          <ul>
            {paragraphMatches.map(match => (
              <li class="paragraph-match">
                <p><span set:html={match.html} /></p>
              </li>
            ))}
          </ul>
        </details>
      </li>
    );
  })}
</ol>

{allMatchingEntries.length > 10 && (
  <div class="pagination">
    <button id="prev-btn" disabled>‚ü®‚ü®</button>
    <span id="page-info">Page 1 of {Math.ceil(allMatchingEntries.length / 10)}</span>
    <button id="next-btn">‚ü©‚ü©</button>
  </div>
)}

<script define:vars={{ allMatchingEntries, textFields }}>
  let currentPage = 1;
  const perPage = 10;
  const totalPages = Math.ceil(allMatchingEntries.length / perPage);
  
  function highlightTerms(paragraph, matches) {
    let result = paragraph;
    
    matches.forEach(match => {
      if (match.similar) {
        match.similar.forEach(word => {
          const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const wordRegex = new RegExp(`\\b(${escapedWord}\\w*)`, 'gi');
          result = result.replace(wordRegex, '<mark style="background-color:transparent; color:var(--highlight-color);">$1</mark>');
        });
      }
    });
    
    matches.forEach(match => {
      const keyword = match.word || match;
      const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const keywordRegex = new RegExp(`\\b(${escapedKeyword}\\w*)`, 'gi');
      result = result.replace(keywordRegex, '<mark style="background-color:transparent; color:var(--hover-color);">$1</mark>');
    });
    
    return result;
  }
  
  function getMatchingParagraphs(text, matches) {
    if (matches.length === 0) return [];
    
    return text
      .split(/\n{2,}/)
      .map(p => p.replace(/\n/g, ' ').trim())
      .filter(p => {
        const lowerP = p.toLowerCase();
        return matches.some(match => {
          const keyword = match.word || match;
          return lowerP.includes(keyword.toLowerCase());
        });
      })
      .map((p, i) => ({ index: i, html: highlightTerms(p, matches) }));
  }
  
  function renderPage(page) {
    const startIndex = (page - 1) * perPage;
    const endIndex = startIndex + perPage;
    const pageEntries = allMatchingEntries.slice(startIndex, endIndex);
    
    const resultsList = document.getElementById('results-list');
    resultsList.innerHTML = '';
    resultsList.setAttribute('start', startIndex + 1);
    
    pageEntries.forEach(entry => {
      const matches = entry.queryMatches || entry.queryTokens || [];
      const paragraphMatches = getMatchingParagraphs(entry[textFields.text], matches);
      
      const li = document.createElement('li');
      li.innerHTML = `
      <style>
      #results-list details summary { cursor: pointer; display: flex; align-items: center; justify-content: space-between; font-weight: bold; font-size: 1.2rem; padding: 0 0 0.5rem 0; }
      #results-list summary::-webkit-details-marker { display: none; }
      #results-list .arrow { display: inline-block; transition: transform 0.2s; border: solid var(--light-text); border-width: 0 2px 2px 0; padding: 3px; margin-left: 4px; transform: rotate(-45deg); }
      #results-list details[open] .arrow { transform: rotate(45deg); }
      html.dark #results-list .arrow { border-color: var(--dark-text); }
      #results-list .paragraph-match { list-style: square;}
      #results-list .paragraph-match p { margin: 0 0 0.5rem 0; font-size: 1.1rem;}
      #results-list .paragraph-match::marker { color: var(--hover-color);}
      #results-list .similarity-score { font-weight: bold; margin-left: 1rem; }
      </style>
        <details>
          <summary>
            <span class="entry-label">
              <strong>${entry[textFields.author]},</strong>
              <a href="${entry[textFields.url]}" target="_blank">${entry[textFields.title]}</a> (${entry[textFields.date]})
              ${entry.similarity > 0 ? `<span class="similarity-score">Similarity: ${entry.similarity.toFixed(4)}</span>` : ''}
            </span>
            <span class="arrow"></span>
          </summary>
          <ul>
            ${paragraphMatches.map(match => `
              <li class="paragraph-match">
                <p><span>${match.html}</span></p>
              </li>
            `).join('')}
          </ul>
        </details>
      `;
      resultsList.appendChild(li);
    });
    
    document.getElementById('prev-btn').disabled = page === 1;
    document.getElementById('next-btn').disabled = page === totalPages;
    document.getElementById('page-info').textContent = `Page ${page} of ${totalPages}`;
  }
  
  document.getElementById('prev-btn')?.addEventListener('click', () => {
    if (currentPage > 1) {
      currentPage--;
      renderPage(currentPage);
    }
  });
  
  document.getElementById('next-btn')?.addEventListener('click', () => {
    if (currentPage < totalPages) {
      currentPage++;
      renderPage(currentPage);
    }
  });
</script>

<style>
  ol {
    padding-left: 1rem;
    margin: 0;
  }
  
  details summary {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-weight: bold;
    font-size: 1.2rem;
    padding: 0 0 0.5rem 0;
  }

  summary::-webkit-details-marker {
    display: none;
  }

  .arrow {
    display: inline-block;
    transition: transform 0.2s;
    border: solid var(--light-text);
    border-width: 0 2px 2px 0;
    padding: 3px;
    margin-left: 4px;
    transform: rotate(-45deg);
  }

  details[open] .arrow {
    transform: rotate(45deg);
  }

  html.dark .arrow {
    border-color: var(--dark-text);
  }

  ul {
    margin: 0 0 1rem 0;
    padding-left: 1.2rem;
    list-style-type: disc;
  }

  .paragraph-match {
    list-style: square;
  }

  .paragraph-match p {
    margin: 0 0 0.5rem 0;
    font-size: 1.1rem;
  }

  .paragraph-match::marker {
    color: var(--hover-color);
  }

  mark {
    background-color: transparent;
    font-weight: bold;
  }

  .similarity-score {
    font-weight: bold;
    margin-left: 1rem;
  }

  .pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin: 1rem 0 2rem 0;
  }
  
  .pagination button {
    padding: 0.5rem 1rem;
    font-size: 1.2rem;
    cursor: pointer;
    font-family: 'IM Fell English', serif;
    border: var(--image-border);
    transition: background-color 0.3s ease, color 0.3s ease;
    background-color: ButtonFace;
  }

  .pagination button:hover:not(:disabled) {
    background-color: var(--hover-color);
    color: white;
  }

  .pagination button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  html.dark .pagination button {
    color: var(--light-text);
  }
</style>
