---
export interface Props {
  nodesData: any[];
  linksData: any[];
  linkDistance?: number;
  chargeStrength?: number;
  centerStrength?: number;
  chargeTheta?: number;
  chargeDistanceMax?: number;
  collisionStrength?: number;
  collisionRadius?: number;
  collisionIterations?: number;
  rotation?: number;
  height?: number;
}

const { 
  nodesData, 
  linksData, 
  linkDistance = 50,
  chargeStrength = -150,
  centerStrength = 1,
  chargeTheta = 0.5,
  chargeDistanceMax = 400,
  collisionStrength = 0.8,
  collisionRadius = 5,
  collisionIterations = 10,
  rotation = 0,
  height = 85 
} = Astro.props;
---

<div id="network"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" defer></script>

<script define:vars={{ 
  nodesData, 
  linksData, 
  linkDistance, 
  chargeStrength, 
  centerStrength, 
  chargeTheta, 
  chargeDistanceMax, 
  collisionStrength, 
  collisionRadius, 
  collisionIterations, 
  rotation, 
  height 
}}>
  function initNetwork() {
    if (!window.d3) {
      setTimeout(initNetwork, 100);
      return;
    }


    const d3 = window.d3;
    // width and height
    const container = d3.select("#network");
    const containerWidth = container.node().getBoundingClientRect().width;
    const w = containerWidth;
    const h = window.innerHeight * (height / 100);

    d3.select("#network").selectAll("*").remove();

    const svg = d3.select("#network")
      .append("svg")
      .attr("width", w)
      .attr("height", h)
      .style('background-color', `var(--viz-background)`)
      .style("border", `var(--image-border)`);

    const g = svg.append("g");


    function translate(d) {
      const svgElem = document.querySelector("#network svg");
      const rectSize = svgElem.getBoundingClientRect();
      const centerX = Math.floor((rectSize.width / 2) * 10000) / 10000;
      const centerY = Math.floor((rectSize.height / 2) * 10000) / 10000;
      
      const relX = d.x - centerX;
      const relY = d.y - centerY;
      
      const radians = (rotation * Math.PI) / 180;
      
      d.x = centerX + relX * Math.cos(radians) - relY * Math.sin(radians);
      d.y = centerY + relX * Math.sin(radians) + relY * Math.cos(radians);
    }



    const simulation = d3.forceSimulation().alpha(1).nodes(nodesData);

    const link_force = d3.forceLink(linksData)
      .id(d => d.name)
      .distance(linkDistance);

    const charge_force = d3.forceManyBody()
      .strength(chargeStrength)
      .theta(chargeTheta)
      .distanceMax(chargeDistanceMax);

    const center_force = d3.forceCenter(w / 2, h / 2)
      .strength(centerStrength)

    const collision_force = d3.forceCollide()
      .strength(collisionStrength)
      .radius(collisionRadius)
      .iterations(collisionIterations);

    simulation
      .force("charge", charge_force)
      .force("center", center_force)
      .force("collision", collision_force)
      .force("link", link_force);

    linksData.forEach(link => {
      if (!link.source.linkCount) link.source.linkCount = 0;
      if (!link.target.linkCount) link.target.linkCount = 0;
      link.source.linkCount++;
      link.target.linkCount++;
    });

    // Add scaling here
    const memberNodes = nodesData.filter(d => d.type === "member");
    const institutionNodes = nodesData.filter(d => d.type !== "member");

    const memberExtent = d3.extent(memberNodes, d => d.linkCount || 0);
    const institutionExtent = d3.extent(institutionNodes, d => d.linkCount || 0);

    const memberScale = d3.scaleLinear().domain(memberExtent).range([3, 10]);
    const institutionScale = d3.scaleLinear().domain(institutionExtent).range([8, 50]);

    const memberFontScale = d3.scaleLinear().domain(memberExtent).range([5, 12]);
    const institutionFontScale = d3.scaleLinear().domain(institutionExtent).range([8, 35]);


    const linkedByIndex = {};
    nodesData.forEach((d, i) => linkedByIndex[i + "," + i] = 1);
    linksData.forEach(d => {
      linkedByIndex[d.source.index + "," + d.target.index] = 1;
      linkedByIndex[d.target.index + "," + d.source.index] = 1;
    });

    const neighboring = (a, b) => linkedByIndex[a.index + "," + b.index];

    const link = g.append("g")
      .selectAll("line")
      .data(linksData)
      .enter()
      .append("line")
      .attr("stroke-width", 0.1)
      .style("stroke", "#a6a6a6");

    const node = g.append("g")
      .selectAll("circle")
      .data(nodesData)
      .enter()
      .append("circle")
      .attr("r", d => d.type === "member" ? memberScale(d.linkCount || 0) : institutionScale(d.linkCount || 0))
      .style("fill", d => d.type === "member" ? "#ffbd80" : "#8aded8")
      .call(d3.drag()
        .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
        .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
        .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }))
      .on("click", (e, d) => {
        const clickedNode = d3.select(e.target);
        const nodeIndex = `node-${d.index}`;
        const isActive = clickedNode.classed("clicked");
        
        if (!isActive) {
          clickedNode.classed("clicked", true);
          node.each(function(n) {
            if (neighboring(d, n) || n === d) {
              d3.select(this).classed(nodeIndex, true);
            }
          });
          link.each(function(l) {
            if (l.source === d || l.target === d) {
              d3.select(this).classed(nodeIndex, true);
            }
          });
        } else {
          clickedNode.classed("clicked", false);
          node.classed(nodeIndex, false);
          link.classed(nodeIndex, false);
        }
        
        node.style("fill", function(n) {
          const hasAnyClass = this.classList.length > 0;
          return hasAnyClass ? "#ff0000" : (n.type === "member" ? "#ffbd80" : "#8aded8");
        });
        
        link.style("stroke", function(l) {
          const hasAnyClass = this.classList.length > 0;
          return hasAnyClass ? "#ff0000" : "#a6a6a6";
        });
      });

    const text = g.append("g")
      .selectAll("text")
      .data(nodesData)
      .enter()
      .append("text")
      .attr("font-size", d => d.type === "member" ? memberFontScale(d.linkCount || 0) : institutionFontScale(d.linkCount || 0))
      .text(d => d.name)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .style("pointer-events", "none");

    svg.call(d3.zoom().on("zoom", e => g.attr("transform", e.transform)));

    // simulation.on("tick", () => {
    //   link.attr("x1", d => translate(d.source).x).attr("y1", d => translate(d.source).y)
    //       .attr("x2", d => translate(d.target).x).attr("y2", d => translate(d.target).y);
    //   node.attr("cx", d => translate(d).x).attr("cy", d => translate(d).y);
    //   text.attr("x", d => translate(d).x).attr("y", d => translate(d).y);
    // });

    simulation.on("tick", () => {
      link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
      node.attr("cx", d => d.x).attr("cy", d => d.y);
      text.attr("x", d => d.x).attr("y", d => d.y);
    });

// Apply translation after simulation settles
setTimeout(() => {
  if (rotation !== 0) {
    nodesData.forEach(translate);
    link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
    node.attr("cx", d => d.x).attr("cy", d => d.y);
    text.attr("x", d => d.x).attr("y", d => d.y);
  }
}, 100);

  }

  initNetwork();
</script>

<style>
  #network { width: 100%; margin: 1rem 0.5rem;}
  circle { cursor: pointer; }
</style>