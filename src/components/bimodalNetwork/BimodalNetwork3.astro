---
export interface Props {
  id?: string;
  nodesData: any[];
  linksData: any[];
  networkType: "bimodal" | "member" | "institution";
  linkDistance?: number;
  chargeStrength?: number;
  centerStrength?: number;
  chargeTheta?: number;
  chargeDistanceMax?: number;
  collisionStrength?: number;
  collisionRadius?: number;
  collisionIterations?: number;
  rotation?: number;
  height?: number;
  filter?: { member?: string[], institution?: string[] };
  display?: boolean;
  // Bimodal props
  memberNodeRange?: [number, number];
  institutionNodeRange?: [number, number];
  memberFontRange?: [number, number];
  institutionFontRange?: [number, number];
  // Unimodal props
  uniNodeRange?: [number, number];
  uniFontRange?: [number, number];
  uniStrokeRange?: [number, number];
  uniZoomScale?: number;
  // Centrality metric for unimodal
  centralityMetric?: "degree" | "betweenness";
}

const { 
  id = "network",
  nodesData, 
  linksData, 
  networkType = "bimodal",
  linkDistance = 50,
  chargeStrength = -150,
  centerStrength = 1,
  chargeTheta = 0.5,
  chargeDistanceMax = 400,
  collisionStrength = 0.8,
  collisionRadius = 5,
  collisionIterations = 10,
  rotation = 0,
  height = 85,
  filter,
  display = true,
  // Bimodal defaults
  memberNodeRange = [3, 8],
  institutionNodeRange = [10, 30],
  memberFontRange = [5, 15],
  institutionFontRange = [15, 30],
  // Unimodal defaults
  uniNodeRange = [5, 20],
  uniFontRange = [8, 16],
  uniStrokeRange = [0.5, 3],
  uniZoomScale = 0.6,
  centralityMetric = "degree"
} = Astro.props;

function convertToUnimodal(nodes, links, type) {
  const targetType = type === "member" ? "member" : "institution";
  
  const uniNodes = nodes.filter(node => 
    (targetType === "member" && node.type === "member") ||
    (targetType === "institution" && node.type !== "member")
  );
  
  const validNodeNames = new Set(uniNodes.map(n => n.name));
  
  // Build institution -> members mapping
  const institutionMembers = new Map();
  links.forEach(link => {
    const source = link.source;
    const target = link.target;
    
    if (targetType === "institution") {
      const member = nodes.find(n => n.name === source && n.type === "member");
      const institution = nodes.find(n => n.name === target && n.type !== "member");
      
      if (member && institution && validNodeNames.has(institution.name)) {
        if (!institutionMembers.has(institution.name)) {
          institutionMembers.set(institution.name, new Set());
        }
        institutionMembers.get(institution.name).add(member.name);
      }
    } else {
      // Handle member projection similarly
      const member = nodes.find(n => n.name === source && n.type === "member");
      const institution = nodes.find(n => n.name === target && n.type !== "member");
      
      if (member && institution && validNodeNames.has(member.name)) {
        if (!institutionMembers.has(member.name)) {
          institutionMembers.set(member.name, new Set());
        }
        institutionMembers.get(member.name).add(institution.name);
      }
    }
  });
  
  // Create links between nodes that share any connections
  const uniLinks = [];
  const linkWeights = new Map();
  
  const nodeNames = Array.from(institutionMembers.keys());
  for (let i = 0; i < nodeNames.length; i++) {
    for (let j = i + 1; j < nodeNames.length; j++) {
      const node1 = nodeNames[i];
      const node2 = nodeNames[j];
      const connections1 = institutionMembers.get(node1);
      const connections2 = institutionMembers.get(node2);
      
      // Count shared connections
      const sharedConnections = new Set([...connections1].filter(c => connections2.has(c)));
      
      if (sharedConnections.size > 0) {
        const linkKey = [node1, node2].sort().join("|||");
        linkWeights.set(linkKey, sharedConnections.size);
      }
    }
  }
  
  linkWeights.forEach((weight, linkKey) => {
    const [source, target] = linkKey.split("|||");
    uniLinks.push({ source, target, weight });
  });
  
  return { nodes: uniNodes, links: uniLinks };
}


function filterData(nodes, links, filter) {
  if (!filter) return { nodes, links };
  
  let memberLinks = [];
  let institutionLinks = [];
  
  if (filter.member?.length) {
    const memberTargets = new Set();
    links.forEach(link => {
      if (filter.member.includes(link.source)) {
        memberTargets.add(link.target);
      }
    });
    memberLinks = links.filter(link => 
      filter.member.includes(link.source) || memberTargets.has(link.target)
    );
  }
  
  if (filter.institution?.length) {
    institutionLinks = links.filter(link => 
      filter.institution.includes(link.target)
    );
  }
  
  let filteredLinks = [];
  if (filter.member?.length && filter.institution?.length) {
    const combinedLinks = [...memberLinks, ...institutionLinks];
    filteredLinks = combinedLinks.filter((link, index, self) => 
      index === self.findIndex(l => l.source === link.source && l.target === link.target)
    );
  } else if (filter.member?.length) {
    filteredLinks = memberLinks;
  } else if (filter.institution?.length) {
    filteredLinks = institutionLinks;
  }
  
  const usedNodes = new Set();
  filteredLinks.forEach(link => {
    usedNodes.add(link.source);
    usedNodes.add(link.target);
  });
  
  const filteredNodes = nodes.filter(node => usedNodes.has(node.name));
  
  return { nodes: filteredNodes, links: filteredLinks };
}

const { nodes: filteredNodes, links: filteredLinks } = filterData(nodesData, linksData, filter);

let finalNodes, finalLinks;
if (networkType === "bimodal") {
  finalNodes = filteredNodes;
  finalLinks = filteredLinks;
} else {
  const { nodes: uniNodes, links: uniLinks } = convertToUnimodal(filteredNodes, filteredLinks, networkType);
  finalNodes = uniNodes;
  finalLinks = uniLinks;
}

const shouldDisplay = networkType === "bimodal" ? display : true;
---

<div id={id} class="network-container" style={shouldDisplay ? "" : "display: none;"}></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" defer></script>

<script define:vars={{
  id, 
  originalNodes: filteredNodes,
  originalLinks: filteredLinks,
  nodesData: finalNodes, 
  linksData: finalLinks, 
  networkType,
  linkDistance, 
  chargeStrength, 
  centerStrength, 
  chargeTheta, 
  chargeDistanceMax, 
  collisionStrength, 
  collisionRadius, 
  collisionIterations, 
  rotation, 
  height,
  memberNodeRange,
  institutionNodeRange,
  memberFontRange,
  institutionFontRange,
  uniNodeRange,
  uniFontRange,
  uniStrokeRange,
  uniZoomScale,
  centralityMetric
}}>
  function bfs(adj, start, end) {
    const queue = [[start]];
    const visited = new Set([start]);
    
    while (queue.length > 0) {
      const path = queue.shift();
      const node = path[path.length - 1];
      
      if (node === end) return path;
      
      for (const neighbor of adj[node] || []) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push([...path, neighbor]);
        }
      }
    }
    return null;
  }

    function dijkstra(adj, start, end) {
        const distances = {};
        const previous = {};
        const unvisited = new Set();
        
        Object.keys(adj).forEach(node => {
            distances[node] = Infinity;
            unvisited.add(node);
        });
        distances[start] = 0;
        
        while (unvisited.size > 0) {
            const current = Array.from(unvisited).reduce((min, node) => 
            distances[node] < distances[min] ? node : min
            );
            
            if (current === end) break;
            unvisited.delete(current);
            
            adj[current].forEach(neighbor => {
            if (unvisited.has(neighbor.node)) {
                const alt = distances[current] + neighbor.weight;
                if (alt < distances[neighbor.node]) {
                distances[neighbor.node] = alt;
                previous[neighbor.node] = current;
                }
            }
            });
        }
        
        const path = [];
        let current = end;
        while (current) {
            path.unshift(current);
            current = previous[current];
        }
        
        return path[0] === start ? path : [];
        }


  function calculateCentrality(nodes, links, metric) {
    if (metric === "degree") {
      nodes.forEach(node => {
        node.linkCount = 0;
        node.weightedDegree = 0;
      });

      links.forEach(link => {
        const sourceNode = nodes.find(n => n.name === (typeof link.source === 'string' ? link.source : link.source.name));
        const targetNode = nodes.find(n => n.name === (typeof link.target === 'string' ? link.target : link.target.name));
        
        if (sourceNode) {
          sourceNode.linkCount++;
          sourceNode.weightedDegree += (link.weight || 1);
        }
        if (targetNode) {
          targetNode.linkCount++;
          targetNode.weightedDegree += (link.weight || 1);
        }
      });

        // Debug: Check for isolated nodes
        const isolatedNodes = nodes.filter(n => n.weightedDegree === 0);
        if (isolatedNodes.length > 0) {
            console.log("Isolated nodes (0 degree):", isolatedNodes.map(n => n.name));
        }

      const result = nodes.map(n => ({ name: n.name, centrality: n.weightedDegree }));
      console.log("Degree centrality:", result.slice(0, 80));
      return result;
        } else if (metric === "betweenness") {
            const centrality = {};
            nodes.forEach(n => centrality[n.name] = 0);
            
            const adj = {};
            nodes.forEach(n => adj[n.name] = []);
            links.forEach(link => {
                const source = typeof link.source === 'string' ? link.source : link.source.name;
                const target = typeof link.target === 'string' ? link.target : link.target.name;
                const weight = 1 / (link.weight || 1);
                adj[source].push({ node: target, weight });
                adj[target].push({ node: source, weight });
            });
            
            nodes.forEach(start => {
                nodes.forEach(end => {
                    if (start.name !== end.name) {
                        const path = dijkstra(adj, start.name, end.name);
                        if (path && path.length > 2) {
                            path.slice(1, -1).forEach(node => centrality[node]++);
                        }
                    }
                });
            });
            
        // Square root transformation - gentler compression
        const result = nodes.map(n => ({ 
            name: n.name, 
            centrality: Math.sqrt(centrality[n.name]) 
        }));
        console.log("Sqrt Betweenness centrality:", result.slice(0, 80));
        return result;

        }

    }


  function initNetwork() {
    if (!window.d3) {
      setTimeout(initNetwork, 100);
      return;
    }

    const d3 = window.d3;
    const container = d3.select(`#${id}`);
    const containerWidth = container.node().getBoundingClientRect().width;
    const w = containerWidth;
    const h = window.innerHeight * (height / 100);

    d3.select(`#${id}`).selectAll("*").remove();

    const svg = d3.select(`#${id}`)
      .append("svg")
      .attr("width", w)
      .attr("height", h)
      .style('background-color', `var(--viz-background)`)
      .style("border", `var(--image-border)`);

    const g = svg.append("g");

    function translate(d) {
      const svgElem = document.querySelector(`#${id} svg`);
      const rectSize = svgElem.getBoundingClientRect();
      const centerX = Math.floor((rectSize.width / 2) * 10000) / 10000;
      const centerY = Math.floor((rectSize.height / 2) * 10000) / 10000;
      
      const relX = d.x - centerX;
      const relY = d.y - centerY;
      
      const radians = (rotation * Math.PI) / 180;
      
      d.x = centerX + relX * Math.cos(radians) - relY * Math.sin(radians);
      d.y = centerY + relX * Math.sin(radians) + relY * Math.cos(radians);
    }

    const simulation = d3.forceSimulation().alpha(1).nodes(nodesData);

    if (networkType === "bimodal") {
      const link_force = d3.forceLink(linksData)
        .id(d => d.name)
        .distance(linkDistance);

      const charge_force = d3.forceManyBody()
        .strength(chargeStrength)
        .theta(chargeTheta)
        .distanceMax(chargeDistanceMax);

      const center_force = d3.forceCenter(w / 2, h / 2)
        .strength(centerStrength);

      const collision_force = d3.forceCollide()
        .strength(collisionStrength)
        .radius(collisionRadius)
        .iterations(collisionIterations);

      simulation
        .force("charge", charge_force)
        .force("center", center_force)
        .force("collision", collision_force)
        .force("link", link_force);

      linksData.forEach(link => {
        if (!link.source.linkCount) link.source.linkCount = 0;
        if (!link.target.linkCount) link.target.linkCount = 0;
        link.source.linkCount++;
        link.target.linkCount++;
      });
    } else {
      const bimodalNodes = originalNodes.map(d => ({...d}));
      
      const bimodalSim = d3.forceSimulation(bimodalNodes)
        .force("link", d3.forceLink(originalLinks).id(d => d.name).distance(linkDistance))
        .force("charge", d3.forceManyBody().strength(chargeStrength))
        .force("center", d3.forceCenter(w/2, h/2).strength(centerStrength))
        .force("collision", d3.forceCollide().radius(collisionRadius))
        .stop();
      
      for (let i = 0; i < 300; ++i) bimodalSim.tick();
      
      nodesData.forEach(node => {
        const bimodalNode = bimodalNodes.find(bn => bn.name === node.name);
        if (bimodalNode) {
          node.x = bimodalNode.x;
          node.y = bimodalNode.y;
          node.fx = bimodalNode.x;
          node.fy = bimodalNode.y;
        } else {
          node.x = w/2 + (Math.random() - 0.5) * 100;
          node.y = h/2 + (Math.random() - 0.5) * 100;
          node.fx = node.x;
          node.fy = node.y;
        }
      });

      g.attr("transform", `translate(${w/2}, ${h/2}) scale(${uniZoomScale}) translate(${-w/2}, ${-h/2})`);

      // Calculate centrality for unimodal networks
      const centralityData = calculateCentrality(nodesData, linksData, centralityMetric);
      
      centralityData.forEach(c => {
        const node = nodesData.find(n => n.name === c.name);
        if (node) node.centrality = c.centrality;
      });

      simulation.stop();
    }

    if (networkType === "bimodal") {
      // BIMODAL SCALING WITH PROPS
      const memberNodes = nodesData.filter(d => d.type === "member");
      const institutionNodes = nodesData.filter(d => d.type !== "member");

      const memberExtent = d3.extent(memberNodes, d => d.linkCount || 0);
      const institutionExtent = d3.extent(institutionNodes, d => d.linkCount || 0);

      const memberScale = d3.scaleLinear().domain(memberExtent).range(memberNodeRange);
      const institutionScale = d3.scaleLinear().domain(institutionExtent).range(institutionNodeRange);

      const memberFontScale = d3.scaleLinear().domain(memberExtent).range(memberFontRange);
      const institutionFontScale = d3.scaleLinear().domain(institutionExtent).range(institutionFontRange);

      const linkedByIndex = {};
      nodesData.forEach((d, i) => linkedByIndex[i + "," + i] = 1);
      linksData.forEach(d => {
        linkedByIndex[d.source.index + "," + d.target.index] = 1;
        linkedByIndex[d.target.index + "," + d.source.index] = 1;
      });

      const neighboring = (a, b) => linkedByIndex[a.index + "," + b.index];

      const link = g.append("g")
        .selectAll("line")
        .data(linksData)
        .enter()
        .append("line")
        .attr("stroke-width", 0.1)
        .style("stroke", "#a6a6a6");

      const node = g.append("g")
        .selectAll("circle")
        .data(nodesData)
        .enter()
        .append("circle")
        .attr("r", d => d.type === "member" ? memberScale(d.linkCount || 0) : institutionScale(d.linkCount || 0))
        .style("fill", d => d.type === "member" ? "#ffbd80" : "#8aded8")
        .call(d3.drag()
          .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
          .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
          .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }))
        .on("click", (e, d) => {
          const clickedNode = d3.select(e.target);
          const nodeIndex = `node-${d.index}`;
          const isActive = clickedNode.classed("clicked");
          
          if (!isActive) {
            clickedNode.classed("clicked", true);
            node.each(function(n) {
              if (neighboring(d, n) || n === d) {
                d3.select(this).classed(nodeIndex, true);
              }
            });
            link.each(function(l) {
              if (l.source === d || l.target === d) {
                d3.select(this).classed(nodeIndex, true);
              }
            });
          } else {
            clickedNode.classed("clicked", false);
            node.classed(nodeIndex, false);
            link.classed(nodeIndex, false);
          }
          
          node.style("fill", function(n) {
            const hasAnyClass = this.classList.length > 0;
            return hasAnyClass ? "#ff0000" : (n.type === "member" ? "#ffbd80" : "#8aded8");
          });
          
          link.style("stroke", function(l) {
            const hasAnyClass = this.classList.length > 0;
            return hasAnyClass ? "#ff0000" : "#a6a6a6";
          });
        });

      const text = g.append("g")
        .selectAll("text")
        .data(nodesData)
        .enter()
        .append("text")
        .attr("font-size", d => d.type === "member" ? memberFontScale(d.linkCount || 0) : institutionFontScale(d.linkCount || 0))
        .text(d => d.name)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("pointer-events", "none");

      simulation.on("tick", () => {
        link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
        node.attr("cx", d => d.x).attr("cy", d => d.y);
        text.attr("x", d => d.x).attr("y", d => d.y);
      });

    } else {
      // UNIMODAL SCALING WITH CENTRALITY
      const linkedByIndex = {};
      nodesData.forEach((d, i) => linkedByIndex[i + "," + i] = 1);
      linksData.forEach(d => {
        linkedByIndex[d.source.index + "," + d.target.index] = 1;
        linkedByIndex[d.target.index + "," + d.source.index] = 1;
      });

      const neighboring = (a, b) => linkedByIndex[a.index + "," + b.index];

      const nodePositions = new Map();
      nodesData.forEach(node => {
        nodePositions.set(node.name, { x: node.x, y: node.y });
      });

      const centralityExtent = d3.extent(nodesData, d => d.centrality || 0);
      const uniNodeScale = d3.scaleLinear().domain(centralityExtent).range(uniNodeRange);
      const uniFontScale = d3.scaleLinear().domain(centralityExtent).range(uniFontRange);

      const weightExtent = d3.extent(linksData, d => d.weight || 1);
      const strokeScale = d3.scaleLinear().domain(weightExtent).range(uniStrokeRange);

      const link = g.append("g")
        .selectAll("line")
        .data(linksData)
        .enter()
        .append("line")
        .attr("stroke-width", d => strokeScale(d.weight || 1))
        .style("stroke", "#a6a6a6")
        .attr("x1", d => {
          const sourcePos = nodePositions.get(typeof d.source === 'string' ? d.source : d.source.name);
          return sourcePos ? sourcePos.x : 0;
        })
        .attr("y1", d => {
          const sourcePos = nodePositions.get(typeof d.source === 'string' ? d.source : d.source.name);
          return sourcePos ? sourcePos.y : 0;
        })
        .attr("x2", d => {
          const targetPos = nodePositions.get(typeof d.target === 'string' ? d.target : d.target.name);
          return targetPos ? targetPos.x : 0;
        })
        .attr("y2", d => {
          const targetPos = nodePositions.get(typeof d.target === 'string' ? d.target : d.target.name);
          return targetPos ? targetPos.y : 0;
        });

      const linkLabels = g.append("g")
        .selectAll("text")
        .data(linksData)
        .enter()
        .append("text")
        .attr("font-size", 8)
        .attr("fill", "#666")
        .attr("text-anchor", "middle")
        .text(d => d.weight || 1)
        .style("pointer-events", "none")
        .attr("x", d => {
          const sourcePos = nodePositions.get(typeof d.source === 'string' ? d.source : d.source.name);
          const targetPos = nodePositions.get(typeof d.target === 'string' ? d.target : d.target.name);
          return ((sourcePos?.x || 0) + (targetPos?.x || 0)) / 2;
        })
        .attr("y", d => {
          const sourcePos = nodePositions.get(typeof d.source === 'string' ? d.source : d.source.name);
          const targetPos = nodePositions.get(typeof d.target === 'string' ? d.target : d.target.name);
          return ((sourcePos?.y || 0) + (targetPos?.y || 0)) / 2;
        });

      const node = g.append("g")
        .selectAll("circle")
        .data(nodesData)
        .enter()
        .append("circle")
        .attr("r", d => uniNodeScale(d.centrality || 0))
        .style("fill", networkType === "member" ? "#ffbd80" : "#8aded8")
        .attr("cx", d => d.x || 0)
        .attr("cy", d => d.y || 0)
.call(d3.drag()
  .on("start", (e, d) => {
    // Don't set any fixed positions
  })
  .on("drag", (e, d) => { 
    d.x = e.x;
    d.y = e.y;
    nodePositions.set(d.name, { x: e.x, y: e.y });
    
    // Update this node's position
    d3.select(e.sourceEvent.target).attr("cx", e.x).attr("cy", e.y);
    
    // Update text for this node
    text.filter(t => t.name === d.name).attr("x", e.x).attr("y", e.y);
    
    // Update all links
    link.attr("x1", function(l) {
      const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
      return sourcePos ? sourcePos.x : 0;
    })
    .attr("y1", function(l) {
      const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
      return sourcePos ? sourcePos.y : 0;
    })
    .attr("x2", function(l) {
      const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
      return targetPos ? targetPos.x : 0;
    })
    .attr("y2", function(l) {
      const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
      return targetPos ? targetPos.y : 0;
    });
    
    linkLabels.attr("x", function(l) {
      const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
      const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
      return ((sourcePos?.x || 0) + (targetPos?.x || 0)) / 2;
    })
    .attr("y", function(l) {
      const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
      const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
      return ((sourcePos?.y || 0) + (targetPos?.y || 0)) / 2;
    });
  })
  .on("end", (e, d) => { 
    // Don't set fixed positions - let nodes move freely
  }))


        
          .on("click", (e, d) => {
          const clickedNode = d3.select(e.target);
          const nodeIndex = `node-${d.index}`;
          const isActive = clickedNode.classed("clicked");
          
          if (!isActive) {
            clickedNode.classed("clicked", true);
            node.each(function(n) {
              if (neighboring(d, n) || n === d) {
                d3.select(this).classed(nodeIndex, true);
              }
            });
            link.each(function(l) {
              const sourceName = typeof l.source === 'string' ? l.source : l.source.name;
              const targetName = typeof l.target === 'string' ? l.target : l.target.name;
              if (sourceName === d.name || targetName === d.name) {
                d3.select(this).classed(nodeIndex, true);
              }
            });
          } else {
            clickedNode.classed("clicked", false);
            node.classed(nodeIndex, false);
            link.classed(nodeIndex, false);
          }
          
          node.style("fill", function(n) {
            const hasAnyClass = this.classList.length > 0;
            return hasAnyClass ? "#ff0000" : (networkType === "member" ? "#ffbd80" : "#8aded8");
          });
          
          link.style("stroke", function(l) {
            const hasAnyClass = this.classList.length > 0;
            return hasAnyClass ? "#ff0000" : "#a6a6a6";
          });
        });

      const text = g.append("g")
        .selectAll("text")
        .data(nodesData)
        .enter()
        .append("text")
        .attr("font-size", d => uniFontScale(d.centrality || 0))
        .text(d => d.name)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("pointer-events", "none")
        .attr("x", d => d.x || 0)
        .attr("y", d => d.y || 0);
    }

    // ZOOM
    if (networkType === "bimodal") {
      svg.call(d3.zoom().on("zoom", e => {
        g.attr("transform", e.transform);
      }));
    } else {
      svg.call(d3.zoom().on("zoom", e => {
        const userZoom = e.transform;
        const baseScale = uniZoomScale;
        const combinedScale = userZoom.k * baseScale;
        
        g.attr("transform", 
          `translate(${w/2 + userZoom.x}, ${h/2 + userZoom.y}) scale(${combinedScale}) translate(${-w/2}, ${-h/2})`
        );
      }));
    }

    setTimeout(() => {
      if (rotation !== 0) {
        nodesData.forEach(translate);
        const link = g.selectAll("line");
        const node = g.selectAll("circle");
        const text = g.selectAll("text");
        
        if (networkType === "bimodal") {
          link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
          node.attr("cx", d => d.x).attr("cy", d => d.y);
          text.attr("x", d => d.x).attr("y", d => d.y);
        } else {
          const nodePositions = new Map();
          nodesData.forEach(n => nodePositions.set(n.name, { x: n.x, y: n.y }));
          
          link.attr("x1", function(l) {
            const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
            return sourcePos ? sourcePos.x : 0;
          })
          .attr("y1", function(l) {
            const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
            return sourcePos ? sourcePos.y : 0;
          })
          .attr("x2", function(l) {
            const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
            return targetPos ? targetPos.x : 0;
          })
          .attr("y2", function(l) {
            const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
            return targetPos ? targetPos.y : 0;
          });
          
          const linkLabels = g.selectAll("text").filter(function() { 
            return this.getAttribute("font-size") === "8"; 
          });
          linkLabels.attr("x", function(l) {
            const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
            const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
            return ((sourcePos?.x || 0) + (targetPos?.x || 0)) / 2;
          })
          .attr("y", function(l) {
            const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
            const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
            return ((sourcePos?.y || 0) + (targetPos?.y || 0)) / 2;
          });
          
          node.attr("cx", d => d.x || 0).attr("cy", d => d.y || 0);
          text.attr("x", d => d.x || 0).attr("y", d => d.y || 0);
        }
      }
    }, 100);
  }

  initNetwork();
</script>

<style>
  .network-container { width: 100%; margin: 2rem 0 2rem 0rem;}
  circle { cursor: pointer; }
</style>
