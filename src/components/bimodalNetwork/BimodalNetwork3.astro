---
export interface Props {
  id?: string;
  nodesData: any[];
  linksData: any[];
  networkType: "bimodal" | "member" | "institution";
  linkDistance?: number;
  chargeStrength?: number;
  centerStrength?: number;
  chargeTheta?: number;
  chargeDistanceMax?: number;
  collisionStrength?: number;
  collisionRadius?: number;
  collisionIterations?: number;
  rotation?: number;
  height?: number;
  filter?: { member?: string[], institution?: string[] };
  display?: boolean;
  // Bimodal props
  memberNodeRange?: [number, number];
  institutionNodeRange?: [number, number];
  memberFontRange?: [number, number];
  institutionFontRange?: [number, number];
  // Unimodal props
  uniNodeRange?: [number, number];
  uniFontRange?: [number, number];
  uniStrokeRange?: [number, number];
  uniZoomScale?: number;
}

const { 
  id = "network",
  nodesData, 
  linksData, 
  networkType = "bimodal",
  linkDistance = 50,
  chargeStrength = -150,
  centerStrength = 1,
  chargeTheta = 0.5,
  chargeDistanceMax = 400,
  collisionStrength = 0.8,
  collisionRadius = 5,
  collisionIterations = 10,
  rotation = 0,
  height = 85,
  filter,
  display = true,
  // Bimodal defaults
  memberNodeRange = [3, 8],
  institutionNodeRange = [10, 30],
  memberFontRange = [5, 15],
  institutionFontRange = [15, 30],
  // Unimodal defaults
  uniNodeRange = [5, 20],
  uniFontRange = [8, 16],
  uniStrokeRange = [0.5, 3],
  uniZoomScale = 0.6
} = Astro.props;

function convertToUnimodal(nodes, links, type) {
  const targetType = type === "member" ? "member" : "institution";
  
  const uniNodes = nodes.filter(node => 
    (targetType === "member" && node.type === "member") ||
    (targetType === "institution" && node.type !== "member")
  );
  
  const validNodeNames = new Set(uniNodes.map(n => n.name));
  const connectionMap = new Map();
  
  links.forEach(link => {
    const source = link.source;
    const target = link.target;
    
    if (targetType === "member") {
      const member = nodes.find(n => n.name === source && n.type === "member");
      const institution = nodes.find(n => n.name === target && n.type !== "member");
      
      if (member && institution && validNodeNames.has(member.name)) {
        if (!connectionMap.has(institution.name)) {
          connectionMap.set(institution.name, new Set());
        }
        connectionMap.get(institution.name).add(member.name);
      }
    } else {
      const member = nodes.find(n => n.name === source && n.type === "member");
      const institution = nodes.find(n => n.name === target && n.type !== "member");
      
      if (member && institution && validNodeNames.has(institution.name)) {
        if (!connectionMap.has(member.name)) {
          connectionMap.set(member.name, new Set());
        }
        connectionMap.get(member.name).add(institution.name);
      }
    }
  });
  
  const uniLinks = [];
  const linkWeights = new Map();
  
  connectionMap.forEach((connectedNodes, connector) => {
    const nodeArray = Array.from(connectedNodes).filter(name => validNodeNames.has(name));
    for (let i = 0; i < nodeArray.length; i++) {
      for (let j = i + 1; j < nodeArray.length; j++) {
        const node1 = nodeArray[i];
        const node2 = nodeArray[j];
        const linkKey = [node1, node2].sort().join("-");
        
        if (!linkWeights.has(linkKey)) {
          linkWeights.set(linkKey, 0);
        }
        linkWeights.set(linkKey, linkWeights.get(linkKey) + 1);
      }
    }
  });
  
  linkWeights.forEach((weight, linkKey) => {
    const [source, target] = linkKey.split("-");
    if (validNodeNames.has(source) && validNodeNames.has(target)) {
      uniLinks.push({ source, target, weight });
    }
  });
  
  return { nodes: uniNodes, links: uniLinks };
}

function filterData(nodes, links, filter) {
  if (!filter) return { nodes, links };
  
  let memberLinks = [];
  let institutionLinks = [];
  
  if (filter.member?.length) {
    const memberTargets = new Set();
    links.forEach(link => {
      if (filter.member.includes(link.source)) {
        memberTargets.add(link.target);
      }
    });
    memberLinks = links.filter(link => 
      filter.member.includes(link.source) || memberTargets.has(link.target)
    );
  }
  
  if (filter.institution?.length) {
    institutionLinks = links.filter(link => 
      filter.institution.includes(link.target)
    );
  }
  
  let filteredLinks = [];
  if (filter.member?.length && filter.institution?.length) {
    const combinedLinks = [...memberLinks, ...institutionLinks];
    filteredLinks = combinedLinks.filter((link, index, self) => 
      index === self.findIndex(l => l.source === link.source && l.target === link.target)
    );
  } else if (filter.member?.length) {
    filteredLinks = memberLinks;
  } else if (filter.institution?.length) {
    filteredLinks = institutionLinks;
  }
  
  const usedNodes = new Set();
  filteredLinks.forEach(link => {
    usedNodes.add(link.source);
    usedNodes.add(link.target);
  });
  
  const filteredNodes = nodes.filter(node => usedNodes.has(node.name));
  
  return { nodes: filteredNodes, links: filteredLinks };
}

const { nodes: filteredNodes, links: filteredLinks } = filterData(nodesData, linksData, filter);

let finalNodes, finalLinks;
if (networkType === "bimodal") {
  finalNodes = filteredNodes;
  finalLinks = filteredLinks;
} else {
  const { nodes: uniNodes, links: uniLinks } = convertToUnimodal(filteredNodes, filteredLinks, networkType);
  finalNodes = uniNodes;
  finalLinks = uniLinks;
}

const shouldDisplay = networkType === "bimodal" ? display : true;
---

<div id={id} class="network-container" style={shouldDisplay ? "" : "display: none;"}></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" defer></script>

<script define:vars={{
  id, 
  originalNodes: filteredNodes,
  originalLinks: filteredLinks,
  nodesData: finalNodes, 
  linksData: finalLinks, 
  networkType,
  linkDistance, 
  chargeStrength, 
  centerStrength, 
  chargeTheta, 
  chargeDistanceMax, 
  collisionStrength, 
  collisionRadius, 
  collisionIterations, 
  rotation, 
  height,
  memberNodeRange,
  institutionNodeRange,
  memberFontRange,
  institutionFontRange,
  uniNodeRange,
  uniFontRange,
  uniStrokeRange,
  uniZoomScale
}}>
  function initNetwork() {
    if (!window.d3) {
      setTimeout(initNetwork, 100);
      return;
    }

    const d3 = window.d3;
    const container = d3.select(`#${id}`);
    const containerWidth = container.node().getBoundingClientRect().width;
    const w = containerWidth;
    const h = window.innerHeight * (height / 100);

    d3.select(`#${id}`).selectAll("*").remove();

    const svg = d3.select(`#${id}`)
      .append("svg")
      .attr("width", w)
      .attr("height", h)
      .style('background-color', `var(--viz-background)`)
      .style("border", `var(--image-border)`);

    const g = svg.append("g");

    function translate(d) {
      const svgElem = document.querySelector(`#${id} svg`);
      const rectSize = svgElem.getBoundingClientRect();
      const centerX = Math.floor((rectSize.width / 2) * 10000) / 10000;
      const centerY = Math.floor((rectSize.height / 2) * 10000) / 10000;
      
      const relX = d.x - centerX;
      const relY = d.y - centerY;
      
      const radians = (rotation * Math.PI) / 180;
      
      d.x = centerX + relX * Math.cos(radians) - relY * Math.sin(radians);
      d.y = centerY + relX * Math.sin(radians) + relY * Math.cos(radians);
    }

    const simulation = d3.forceSimulation().alpha(1).nodes(nodesData);

    if (networkType === "bimodal") {
      const link_force = d3.forceLink(linksData)
        .id(d => d.name)
        .distance(linkDistance);

      const charge_force = d3.forceManyBody()
        .strength(chargeStrength)
        .theta(chargeTheta)
        .distanceMax(chargeDistanceMax);

      const center_force = d3.forceCenter(w / 2, h / 2)
        .strength(centerStrength);

      const collision_force = d3.forceCollide()
        .strength(collisionStrength)
        .radius(collisionRadius)
        .iterations(collisionIterations);

      simulation
        .force("charge", charge_force)
        .force("center", center_force)
        .force("collision", collision_force)
        .force("link", link_force);

      linksData.forEach(link => {
        if (!link.source.linkCount) link.source.linkCount = 0;
        if (!link.target.linkCount) link.target.linkCount = 0;
        link.source.linkCount++;
        link.target.linkCount++;
      });
    } else {
      const bimodalNodes = originalNodes.map(d => ({...d}));
      
      const bimodalSim = d3.forceSimulation(bimodalNodes)
        .force("link", d3.forceLink(originalLinks).id(d => d.name).distance(linkDistance))
        .force("charge", d3.forceManyBody().strength(chargeStrength))
        .force("center", d3.forceCenter(w/2, h/2).strength(centerStrength))
        .force("collision", d3.forceCollide().radius(collisionRadius))
        .stop();
      
      for (let i = 0; i < 300; ++i) bimodalSim.tick();
      
      nodesData.forEach(node => {
        const bimodalNode = bimodalNodes.find(bn => bn.name === node.name);
        if (bimodalNode) {
          node.x = bimodalNode.x;
          node.y = bimodalNode.y;
          node.fx = bimodalNode.x;
          node.fy = bimodalNode.y;
        } else {
          node.x = w/2 + (Math.random() - 0.5) * 100;
          node.y = h/2 + (Math.random() - 0.5) * 100;
          node.fx = node.x;
          node.fy = node.y;
        }
      });

      // Apply zoom transform for unimodal
      g.attr("transform", `translate(${w/2}, ${h/2}) scale(${uniZoomScale}) translate(${-w/2}, ${-h/2})`);

      nodesData.forEach(node => {
        node.linkCount = 0;
      });

      linksData.forEach(link => {
        const sourceNode = nodesData.find(n => n.name === (typeof link.source === 'string' ? link.source : link.source.name));
        const targetNode = nodesData.find(n => n.name === (typeof link.target === 'string' ? link.target : link.target.name));
        
        if (sourceNode) sourceNode.linkCount++;
        if (targetNode) targetNode.linkCount++;
      });

      simulation.stop();
    }

    if (networkType === "bimodal") {
      // BIMODAL SCALING WITH PROPS
      const memberNodes = nodesData.filter(d => d.type === "member");
      const institutionNodes = nodesData.filter(d => d.type !== "member");

      const memberExtent = d3.extent(memberNodes, d => d.linkCount || 0);
      const institutionExtent = d3.extent(institutionNodes, d => d.linkCount || 0);

      const memberScale = d3.scaleLinear().domain(memberExtent).range(memberNodeRange);
      const institutionScale = d3.scaleLinear().domain(institutionExtent).range(institutionNodeRange);

      const memberFontScale = d3.scaleLinear().domain(memberExtent).range(memberFontRange);
      const institutionFontScale = d3.scaleLinear().domain(institutionExtent).range(institutionFontRange);

      const linkedByIndex = {};
      nodesData.forEach((d, i) => linkedByIndex[i + "," + i] = 1);
      linksData.forEach(d => {
        linkedByIndex[d.source.index + "," + d.target.index] = 1;
        linkedByIndex[d.target.index + "," + d.source.index] = 1;
      });

      const neighboring = (a, b) => linkedByIndex[a.index + "," + b.index];

      const link = g.append("g")
        .selectAll("line")
        .data(linksData)
        .enter()
        .append("line")
        .attr("stroke-width", 0.1)
        .style("stroke", "#a6a6a6");

      const node = g.append("g")
        .selectAll("circle")
        .data(nodesData)
        .enter()
        .append("circle")
        .attr("r", d => d.type === "member" ? memberScale(d.linkCount || 0) : institutionScale(d.linkCount || 0))
        .style("fill", d => d.type === "member" ? "#ffbd80" : "#8aded8")
        .call(d3.drag()
          .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
          .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
          .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }))
        .on("click", (e, d) => {
          const clickedNode = d3.select(e.target);
          const nodeIndex = `node-${d.index}`;
          const isActive = clickedNode.classed("clicked");
          
          if (!isActive) {
            clickedNode.classed("clicked", true);
            node.each(function(n) {
              if (neighboring(d, n) || n === d) {
                d3.select(this).classed(nodeIndex, true);
              }
            });
            link.each(function(l) {
              if (l.source === d || l.target === d) {
                d3.select(this).classed(nodeIndex, true);
              }
            });
          } else {
            clickedNode.classed("clicked", false);
            node.classed(nodeIndex, false);
            link.classed(nodeIndex, false);
          }
          
          node.style("fill", function(n) {
            const hasAnyClass = this.classList.length > 0;
            return hasAnyClass ? "#ff0000" : (n.type === "member" ? "#ffbd80" : "#8aded8");
          });
          
          link.style("stroke", function(l) {
            const hasAnyClass = this.classList.length > 0;
            return hasAnyClass ? "#ff0000" : "#a6a6a6";
          });
        });

      const text = g.append("g")
        .selectAll("text")
        .data(nodesData)
        .enter()
        .append("text")
        .attr("font-size", d => d.type === "member" ? memberFontScale(d.linkCount || 0) : institutionFontScale(d.linkCount || 0))
        .text(d => d.name)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("pointer-events", "none");

      simulation.on("tick", () => {
        link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
        node.attr("cx", d => d.x).attr("cy", d => d.y);
        text.attr("x", d => d.x).attr("y", d => d.y);
      });

    } else {
      // UNIMODAL SCALING WITH PROPS
      const linkedByIndex = {};
      nodesData.forEach((d, i) => linkedByIndex[i + "," + i] = 1);
      linksData.forEach(d => {
        linkedByIndex[d.source.index + "," + d.target.index] = 1;
        linkedByIndex[d.target.index + "," + d.source.index] = 1;
      });

      const neighboring = (a, b) => linkedByIndex[a.index + "," + b.index];

      const nodePositions = new Map();
      nodesData.forEach(node => {
        nodePositions.set(node.name, { x: node.x, y: node.y });
      });

      const nodeExtent = d3.extent(nodesData, d => d.linkCount || 0);
      const uniNodeScale = d3.scaleLinear().domain(nodeExtent).range(uniNodeRange);
      const uniFontScale = d3.scaleLinear().domain(nodeExtent).range(uniFontRange);

      const weightExtent = d3.extent(linksData, d => d.weight || 1);
      const strokeScale = d3.scaleLinear().domain(weightExtent).range(uniStrokeRange);

      const link = g.append("g")
        .selectAll("line")
        .data(linksData)
        .enter()
        .append("line")
        .attr("stroke-width", d => strokeScale(d.weight || 1))
        .style("stroke", "#a6a6a6")
        .attr("x1", d => {
          const sourcePos = nodePositions.get(typeof d.source === 'string' ? d.source : d.source.name);
          return sourcePos ? sourcePos.x : 0;
        })
        .attr("y1", d => {
          const sourcePos = nodePositions.get(typeof d.source === 'string' ? d.source : d.source.name);
          return sourcePos ? sourcePos.y : 0;
        })
        .attr("x2", d => {
          const targetPos = nodePositions.get(typeof d.target === 'string' ? d.target : d.target.name);
          return targetPos ? targetPos.x : 0;
        })
        .attr("y2", d => {
          const targetPos = nodePositions.get(typeof d.target === 'string' ? d.target : d.target.name);
          return targetPos ? targetPos.y : 0;
        });

      const linkLabels = g.append("g")
        .selectAll("text")
        .data(linksData)
        .enter()
        .append("text")
        .attr("font-size", 8)
        .attr("fill", "#666")
        .attr("text-anchor", "middle")
        .text(d => d.weight || 1)
        .style("pointer-events", "none")
        .attr("x", d => {
          const sourcePos = nodePositions.get(typeof d.source === 'string' ? d.source : d.source.name);
          const targetPos = nodePositions.get(typeof d.target === 'string' ? d.target : d.target.name);
          return ((sourcePos?.x || 0) + (targetPos?.x || 0)) / 2;
        })
        .attr("y", d => {
          const sourcePos = nodePositions.get(typeof d.source === 'string' ? d.source : d.source.name);
          const targetPos = nodePositions.get(typeof d.target === 'string' ? d.target : d.target.name);
          return ((sourcePos?.y || 0) + (targetPos?.y || 0)) / 2;
        });

      const node = g.append("g")
        .selectAll("circle")
        .data(nodesData)
        .enter()
        .append("circle")
        .attr("r", d => uniNodeScale(d.linkCount || 0))
        .style("fill", networkType === "member" ? "#ffbd80" : "#8aded8")
        .attr("cx", d => d.x || 0)
        .attr("cy", d => d.y || 0)
        .call(d3.drag()
          .on("start", (e, d) => { d.fx = d.x; d.fy = d.y; })
          .on("drag", (e, d) => { 
            d.fx = e.x; 
            d.fy = e.y;
            d.x = e.x;
            d.y = e.y;
            nodePositions.set(d.name, { x: e.x, y: e.y });
            
            link.attr("x1", function(l) {
              const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
              return sourcePos ? sourcePos.x : 0;
            })
            .attr("y1", function(l) {
              const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
              return sourcePos ? sourcePos.y : 0;
            })
            .attr("x2", function(l) {
              const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
              return targetPos ? targetPos.x : 0;
            })
            .attr("y2", function(l) {
              const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
              return targetPos ? targetPos.y : 0;
            });
            
            linkLabels.attr("x", function(l) {
              const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
              const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
              return ((sourcePos?.x || 0) + (targetPos?.x || 0)) / 2;
            })
            .attr("y", function(l) {
              const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
              const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
              return ((sourcePos?.y || 0) + (targetPos?.y || 0)) / 2;
            });
          })
          .on("end", (e, d) => { d.fx = e.x; d.fy = e.y; }))
        .on("click", (e, d) => {
          const clickedNode = d3.select(e.target);
          const nodeIndex = `node-${d.index}`;
          const isActive = clickedNode.classed("clicked");
          
          if (!isActive) {
            clickedNode.classed("clicked", true);
            node.each(function(n) {
              if (neighboring(d, n) || n === d) {
                d3.select(this).classed(nodeIndex, true);
              }
            });
            link.each(function(l) {
              const sourceName = typeof l.source === 'string' ? l.source : l.source.name;
              const targetName = typeof l.target === 'string' ? l.target : l.target.name;
              if (sourceName === d.name || targetName === d.name) {
                d3.select(this).classed(nodeIndex, true);
              }
            });
          } else {
            clickedNode.classed("clicked", false);
            node.classed(nodeIndex, false);
            link.classed(nodeIndex, false);
          }
          
          node.style("fill", function(n) {
            const hasAnyClass = this.classList.length > 0;
            return hasAnyClass ? "#ff0000" : (networkType === "member" ? "#ffbd80" : "#8aded8");
          });
          
          link.style("stroke", function(l) {
            const hasAnyClass = this.classList.length > 0;
            return hasAnyClass ? "#ff0000" : "#a6a6a6";
          });
        });

      const text = g.append("g")
        .selectAll("text")
        .data(nodesData)
        .enter()
        .append("text")
        .attr("font-size", d => uniFontScale(d.linkCount || 0))
        .text(d => d.name)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("pointer-events", "none")
        .attr("x", d => d.x || 0)
        .attr("y", d => d.y || 0);
    }

        // ZOOM - Fixed for unimodal networks
        if (networkType === "bimodal") {
        svg.call(d3.zoom().on("zoom", e => {
            g.attr("transform", e.transform);
        }));
        } else {
        // For unimodal, preserve the base zoom scale
        svg.call(d3.zoom().on("zoom", e => {
            const userZoom = e.transform;
            const baseScale = uniZoomScale;
            const combinedScale = userZoom.k * baseScale;
            
            g.attr("transform", 
            `translate(${w/2 + userZoom.x}, ${h/2 + userZoom.y}) scale(${combinedScale}) translate(${-w/2}, ${-h/2})`
            );
        }));
        }

    setTimeout(() => {
      if (rotation !== 0) {
        nodesData.forEach(translate);
        const link = g.selectAll("line");
        const node = g.selectAll("circle");
        const text = g.selectAll("text");
        
        if (networkType === "bimodal") {
          link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
          node.attr("cx", d => d.x).attr("cy", d => d.y);
          text.attr("x", d => d.x).attr("y", d => d.y);
        } else {
          const nodePositions = new Map();
          nodesData.forEach(n => nodePositions.set(n.name, { x: n.x, y: n.y }));
          
          link.attr("x1", function(l) {
            const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
            return sourcePos ? sourcePos.x : 0;
          })
          .attr("y1", function(l) {
            const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
            return sourcePos ? sourcePos.y : 0;
          })
          .attr("x2", function(l) {
            const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
            return targetPos ? targetPos.x : 0;
          })
          .attr("y2", function(l) {
            const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
            return targetPos ? targetPos.y : 0;
          });
          
          const linkLabels = g.selectAll("text").filter(function() { 
            return this.getAttribute("font-size") === "8"; 
          });
          linkLabels.attr("x", function(l) {
            const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
            const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
            return ((sourcePos?.x || 0) + (targetPos?.x || 0)) / 2;
          })
          .attr("y", function(l) {
            const sourcePos = nodePositions.get(typeof l.source === 'string' ? l.source : l.source.name);
            const targetPos = nodePositions.get(typeof l.target === 'string' ? l.target : l.target.name);
            return ((sourcePos?.y || 0) + (targetPos?.y || 0)) / 2;
          });
          
          node.attr("cx", d => d.x || 0).attr("cy", d => d.y || 0);
          text.attr("x", d => d.x || 0).attr("y", d => d.y || 0);
        }
      }
    }, 100);
  }

  initNetwork();
</script>

<style>
  .network-container { width: 100%; margin: 2rem 0 2rem 0rem;}
  circle { cursor: pointer; }
</style>
