---
export interface Props {
  id?: string;
  nodesData: any[];
  linksData: any[];
  linkDistance?: number;
  chargeStrength?: number;
  centerStrength?: number;
  chargeTheta?: number;
  chargeDistanceMax?: number;
  collisionStrength?: number;
  collisionRadius?: number;
  collisionIterations?: number;
  rotation?: number;
  height?: number;
  filter?: { member?: string[], institution?: string[] };
  // Node size ranges
  memberNodeRange?: [number, number];
  institutionNodeRange?: [number, number];
  // Font size ranges
  memberFontRange?: [number, number];
  institutionFontRange?: [number, number];
}

const { 
  id = "network",
  nodesData, 
  linksData, 
  linkDistance = 50,
  chargeStrength = -150,
  centerStrength = 1,
  chargeTheta = 0.5,
  chargeDistanceMax = 400,
  collisionStrength = 0.8,
  collisionRadius = 5,
  collisionIterations = 10,
  rotation = 0,
  height = 85,
  filter,
    // Defaults for node and font ranges
  memberNodeRange = [3, 8],
  institutionNodeRange = [10, 30],
  memberFontRange = [5, 15],
  institutionFontRange = [15, 30]
} = Astro.props;

function filterData(nodes, links, filter) {
  if (!filter) return { nodes, links };
  
  let memberLinks = [];
  let institutionLinks = [];
  
  // Handle member filtering - get all links where member targets appear
  if (filter.member?.length) {
    const memberTargets = new Set();
    links.forEach(link => {
      if (filter.member.includes(link.source)) {
        memberTargets.add(link.target);
      }
    });
    memberLinks = links.filter(link => 
      filter.member.includes(link.source) || memberTargets.has(link.target)
    );
  }
  
  // Handle institution filtering - simple target match
  if (filter.institution?.length) {
    institutionLinks = links.filter(link => 
      filter.institution.includes(link.target)
    );
  }
  
  // Combine results
  let filteredLinks = [];
  if (filter.member?.length && filter.institution?.length) {
    // Union of both filters
    const combinedLinks = [...memberLinks, ...institutionLinks];
    filteredLinks = combinedLinks.filter((link, index, self) => 
      index === self.findIndex(l => l.source === link.source && l.target === link.target)
    );
  } else if (filter.member?.length) {
    filteredLinks = memberLinks;
  } else if (filter.institution?.length) {
    filteredLinks = institutionLinks;
  }
  
  const usedNodes = new Set();
  filteredLinks.forEach(link => {
    usedNodes.add(link.source);
    usedNodes.add(link.target);
  });
  
  const filteredNodes = nodes.filter(node => usedNodes.has(node.name));
  
  return { nodes: filteredNodes, links: filteredLinks };
}

const { nodes: filteredNodes, links: filteredLinks } = filterData(nodesData, linksData, filter);
---

<div id={id} class="network-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" defer></script>

<script define:vars={{
  id, 
  nodesData: filteredNodes, 
  linksData: filteredLinks, 
  linkDistance, 
  chargeStrength, 
  centerStrength, 
  chargeTheta, 
  chargeDistanceMax, 
  collisionStrength, 
  collisionRadius, 
  collisionIterations, 
  rotation, 
  height,
  memberNodeRange,
  institutionNodeRange,
  memberFontRange,
  institutionFontRange 
}}>
  function initNetwork() {
    if (!window.d3) {
      setTimeout(initNetwork, 100);
      return;
    }

    const d3 = window.d3;
    const container = d3.select(`#${id}`);
    const containerWidth = container.node().getBoundingClientRect().width;
    const w = containerWidth;
    const h = window.innerHeight * (height / 100);

    d3.select(`#${id}`).selectAll("*").remove();

    const svg = d3.select(`#${id}`)
      .append("svg")
      .attr("width", w)
      .attr("height", h)
      .style('background-color', `var(--viz-background)`)
      .style("border", `var(--image-border)`);

    const g = svg.append("g");

    function translate(d) {
      const svgElem = document.querySelector(`#${id} svg`);
      const rectSize = svgElem.getBoundingClientRect();
      const centerX = Math.floor((rectSize.width / 2) * 10000) / 10000;
      const centerY = Math.floor((rectSize.height / 2) * 10000) / 10000;
      
      const relX = d.x - centerX;
      const relY = d.y - centerY;
      
      const radians = (rotation * Math.PI) / 180;
      
      d.x = centerX + relX * Math.cos(radians) - relY * Math.sin(radians);
      d.y = centerY + relX * Math.sin(radians) + relY * Math.cos(radians);
    }

    const simulation = d3.forceSimulation().alpha(1).nodes(nodesData);

    const link_force = d3.forceLink(linksData)
      .id(d => d.name)
      .distance(linkDistance);

    const charge_force = d3.forceManyBody()
      .strength(chargeStrength)
      .theta(chargeTheta)
      .distanceMax(chargeDistanceMax);

    const center_force = d3.forceCenter(w / 2, h / 2)
      .strength(centerStrength);

    const collision_force = d3.forceCollide()
      .strength(collisionStrength)
      .radius(collisionRadius)
      .iterations(collisionIterations);

    simulation
      .force("charge", charge_force)
      .force("center", center_force)
      .force("collision", collision_force)
      .force("link", link_force);

    linksData.forEach(link => {
      if (!link.source.linkCount) link.source.linkCount = 0;
      if (!link.target.linkCount) link.target.linkCount = 0;
      link.source.linkCount++;
      link.target.linkCount++;
    });

    const memberNodes = nodesData.filter(d => d.type === "member");
    const institutionNodes = nodesData.filter(d => d.type !== "member");

    const memberExtent = d3.extent(memberNodes, d => d.linkCount || 0);
    const institutionExtent = d3.extent(institutionNodes, d => d.linkCount || 0);

    const memberScale = d3.scaleLinear().domain(memberExtent).range(memberNodeRange);
    const institutionScale = d3.scaleLinear().domain(institutionExtent).range(institutionNodeRange);

    const memberFontScale = d3.scaleLinear().domain(memberExtent).range(memberFontRange);
    const institutionFontScale = d3.scaleLinear().domain(institutionExtent).range(institutionFontRange);

    const linkedByIndex = {};
    nodesData.forEach((d, i) => linkedByIndex[i + "," + i] = 1);
    linksData.forEach(d => {
      linkedByIndex[d.source.index + "," + d.target.index] = 1;
      linkedByIndex[d.target.index + "," + d.source.index] = 1;
    });

    const neighboring = (a, b) => linkedByIndex[a.index + "," + b.index];

    const link = g.append("g")
      .selectAll("line")
      .data(linksData)
      .enter()
      .append("line")
      .attr("stroke-width", 0.1)
      .style("stroke", "#a6a6a6");

    const node = g.append("g")
      .selectAll("circle")
      .data(nodesData)
      .enter()
      .append("circle")
      .attr("r", d => d.type === "member" ? memberScale(d.linkCount || 0) : institutionScale(d.linkCount || 0))
      .style("fill", d => d.type === "member" ? "#ffbd80" : "#8aded8")
      .call(d3.drag()
        .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
        .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
        .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }))
      .on("click", (e, d) => {
        const clickedNode = d3.select(e.target);
        const nodeIndex = `node-${d.index}`;
        const isActive = clickedNode.classed("clicked");
        
        if (!isActive) {
          clickedNode.classed("clicked", true);
          node.each(function(n) {
            if (neighboring(d, n) || n === d) {
              d3.select(this).classed(nodeIndex, true);
            }
          });
          link.each(function(l) {
            if (l.source === d || l.target === d) {
              d3.select(this).classed(nodeIndex, true);
            }
          });
        } else {
          clickedNode.classed("clicked", false);
          node.classed(nodeIndex, false);
          link.classed(nodeIndex, false);
        }
        
        node.style("fill", function(n) {
          const hasAnyClass = this.classList.length > 0;
          return hasAnyClass ? "#ff0000" : (n.type === "member" ? "#ffbd80" : "#8aded8");
        });
        
        link.style("stroke", function(l) {
          const hasAnyClass = this.classList.length > 0;
          return hasAnyClass ? "#ff0000" : "#a6a6a6";
        });
      });

    const text = g.append("g")
      .selectAll("text")
      .data(nodesData)
      .enter()
      .append("text")
      .attr("font-size", d => d.type === "member" ? memberFontScale(d.linkCount || 0) : institutionFontScale(d.linkCount || 0))
      .text(d => d.name)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .style("pointer-events", "none");

    svg.call(d3.zoom().on("zoom", e => g.attr("transform", e.transform)));

    simulation.on("tick", () => {
      link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
      node.attr("cx", d => d.x).attr("cy", d => d.y);
      text.attr("x", d => d.x).attr("y", d => d.y);
    });

    setTimeout(() => {
      if (rotation !== 0) {
        nodesData.forEach(translate);
        link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
        node.attr("cx", d => d.x).attr("cy", d => d.y);
        text.attr("x", d => d.x).attr("y", d => d.y);
      }
    }, 100);
  }

  initNetwork();
</script>

<style>
  .network-container { width: 100%; margin: 2rem 0 2rem 0rem;}
  circle { cursor: pointer; }
</style>
