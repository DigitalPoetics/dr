---
export interface Props {
  id?: string;
  nodesData: any[];
  linksData: any[];
  linkDistance?: number;
  linkStrength?: number;
  chargeStrength?: number;
  chargeTheta?: number;
  chargeDistanceMax?: number;
  centerStrength?: number;
  collisionRadius?: number;
  collisionStrength?: number;
  forceXStrength?: number | null;
  forceYStrength?: number | null;
  alphaDecay?: number;
  maxIterations?: number;
  rotation?: number;
  height?: number;
  filter?: { member?: string[], institution?: string[] };
  // Node size ranges
  memberNodeRange?: [number, number];
  institutionNodeRange?: [number, number];
  // Font size ranges
  memberFontRange?: [number, number];
  institutionFontRange?: [number, number];
  clickedNodes?: { nodes: string[], color?: string };
}

const { 
  id = "network",
  nodesData, 
  linksData, 
  linkDistance = 50,
  linkStrength = 0.7,
  chargeStrength = -300,
  chargeTheta = 0.8,
  chargeDistanceMax = 300,
  centerStrength = 0.1,
  collisionRadius = 8,
  collisionStrength = 0.8,
  forceXStrength = null,
  forceYStrength = null,
  alphaDecay = 0.02,
  maxIterations = 1000,
  rotation = 0,
  height = 85,
  filter,
  // Node and font ranges
  memberNodeRange = [3, 8],
  institutionNodeRange = [10, 30],
  memberFontRange = [5, 15],
  institutionFontRange = [15, 30],
  clickedNodes
} = Astro.props;

function filterData(nodes, links, filter) {
  if (!filter) return { nodes, links };
  
  let memberLinks = [];
  let institutionLinks = [];
  
  if (filter.member?.length) {
    const memberTargets = new Set();
    links.forEach(link => {
      if (filter.member.includes(link.source)) {
        memberTargets.add(link.target);
      }
    });
    memberLinks = links.filter(link => 
      filter.member.includes(link.source) || memberTargets.has(link.target)
    );
  }
  
  if (filter.institution?.length) {
    institutionLinks = links.filter(link => 
      filter.institution.includes(link.target)
    );
  }
  
  let filteredLinks = [];
  if (filter.member?.length && filter.institution?.length) {
    const combinedLinks = [...memberLinks, ...institutionLinks];
    filteredLinks = combinedLinks.filter((link, index, self) => 
      index === self.findIndex(l => l.source === link.source && l.target === link.target)
    );
  } else if (filter.member?.length) {
    filteredLinks = memberLinks;
  } else if (filter.institution?.length) {
    filteredLinks = institutionLinks;
  }
  
  const usedNodes = new Set();
  filteredLinks.forEach(link => {
    usedNodes.add(link.source);
    usedNodes.add(link.target);
  });
  
  const filteredNodes = nodes.filter(node => usedNodes.has(node.name));
  
  return { nodes: filteredNodes, links: filteredLinks };
}

const { nodes: filteredNodes, links: filteredLinks } = filterData(nodesData, linksData, filter);
---

<div id={id} class="network-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" defer></script>

<script define:vars={{
  id, 
  nodesData: filteredNodes, 
  linksData: filteredLinks, 
  linkDistance,
  linkStrength,
  chargeStrength,
  chargeTheta,
  chargeDistanceMax,
  centerStrength,
  collisionRadius,
  collisionStrength,
  forceXStrength,
  forceYStrength,
  alphaDecay,
  maxIterations,
  rotation, 
  height,
  memberNodeRange,
  institutionNodeRange,
  memberFontRange,
  institutionFontRange,
  clickedNodes 
}}>
  function initNetwork() {
    if (!window.d3) {
      setTimeout(initNetwork, 100);
      return;
    }

    const d3 = window.d3;
    const container = d3.select(`#${id}`);
    const containerWidth = container.node().getBoundingClientRect().width;
    const w = containerWidth;
    const h = window.innerHeight * (height / 100);

    d3.select(`#${id}`).selectAll("*").remove();

    const svg = d3.select(`#${id}`)
      .append("svg")
      .attr("width", w)
      .attr("height", h)
      .style('background-color', `var(--viz-background)`)
      .style("border", `var(--image-border)`);

    const g = svg.append("g");

    function translate(d) {
      const svgElem = document.querySelector(`#${id} svg`);
      const rectSize = svgElem.getBoundingClientRect();
      const centerX = Math.floor((rectSize.width / 2) * 10000) / 10000;
      const centerY = Math.floor((rectSize.height / 2) * 10000) / 10000;
      
      const relX = d.x - centerX;
      const relY = d.y - centerY;
      
      const radians = (rotation * Math.PI) / 180;
      
      d.x = centerX + relX * Math.cos(radians) - relY * Math.sin(radians);
      d.y = centerY + relX * Math.sin(radians) + relY * Math.cos(radians);
    }

    // Standard simulation setup
    const simulation = d3.forceSimulation(nodesData)
      .alpha(1)
      .alphaDecay(alphaDecay)

    // Link force
    const link_force = d3.forceLink(linksData)
      .id(d => d.name)
      .distance(linkDistance)
      .strength(linkStrength);

    // Charge force
    const charge_force = d3.forceManyBody()
      .strength(chargeStrength)
      .theta(chargeTheta)
      .distanceMax(chargeDistanceMax);

    // Center force
    const center_force = d3.forceCenter(w / 2, h / 2)
      .strength(centerStrength);

      // force x, y
    const force_x = d3.forceX(w / 2)
      .strength(forceXStrength);

    const force_y = d3.forceY(h / 2)
      .strength(forceYStrength);

    // Calculate linkCount on actual nodes
    nodesData.forEach(node => {
        node.linkCount = linksData.filter(link => 
            link.source === node.name || link.target === node.name
        ).length;
    });

    const memberNodes = nodesData.filter(d => d.type === "member");
    const institutionNodes = nodesData.filter(d => d.type !== "member");

    const memberExtent = d3.extent(memberNodes, d => d.linkCount || 0);
    const institutionExtent = d3.extent(institutionNodes, d => d.linkCount || 0);

    const memberScale = d3.scaleLinear().domain(memberExtent).range(memberNodeRange);
    const institutionScale = d3.scaleLinear().domain(institutionExtent).range(institutionNodeRange);

    const memberFontScale = d3.scaleLinear().domain(memberExtent).range(memberFontRange);
    const institutionFontScale = d3.scaleLinear().domain(institutionExtent).range(institutionFontRange);

    // Collision force
    const collision_force = d3.forceCollide()
        .radius(d => {
            const nodeRadius = d.type === "member" ? memberScale(d.linkCount || 0) : institutionScale(d.linkCount || 0);
            return nodeRadius + collisionRadius;
        })      
        .strength(collisionStrength)
        .iterations(3);



    simulation
      .force("link", link_force)
      .force("charge", charge_force)
      .force("center", center_force)

    if (centerStrength !== null && centerStrength !== 0) {
      simulation.force("center", center_force);
    }

    if (forceXStrength !== null && forceXStrength !== 0) {
      simulation.force("x", force_x);
    }

    if (forceYStrength !== null && forceYStrength !== 0) {
      simulation.force("y", force_y);
    }

    simulation.force("collision", collision_force);

    const linkedByIndex = {};
    nodesData.forEach((d, i) => linkedByIndex[i + "," + i] = 1);
    linksData.forEach(d => {
      linkedByIndex[d.source.index + "," + d.target.index] = 1;
      linkedByIndex[d.target.index + "," + d.source.index] = 1;
    });

    const neighboring = (a, b) => linkedByIndex[a.index + "," + b.index];

    const link = g.append("g")
      .selectAll("line")
      .data(linksData)
      .enter()
      .append("line")
      .attr("stroke-width", 0.1)
      .style("stroke", "#a6a6a6");

    const node = g.append("g")
      .selectAll("circle")
      .data(nodesData)
      .enter()
      .append("circle")
      .attr("r", d => d.type === "member" ? memberScale(d.linkCount || 0) : institutionScale(d.linkCount || 0))
      .style("fill", d => d.type === "member" ? "#ffbd80" : "#8aded8")
      .call(d3.drag()
        .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
        .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
        .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }))
      .on("click", (e, d) => {
        const clickedNode = d3.select(e.target);
        const nodeIndex = `node-${d.index}`;
        const isActive = clickedNode.classed("clicked");

        if (!isActive) {
          clickedNode.classed("clicked", true);
          node.each(function(n) {
            if (neighboring(d, n) || n === d) {
              d3.select(this).classed(nodeIndex, true);
            }
          });
          link.each(function(l) {
            if (l.source === d || l.target === d) {
              d3.select(this).classed(nodeIndex, true);
            }
          });
        } else {
          clickedNode.classed("clicked", false);
          node.classed(nodeIndex, false);
          link.classed(nodeIndex, false);
        }
        
        node.style("fill", function(n) {
          const hasAnyClass = this.classList.length > 0;
          return hasAnyClass ? "#ff0000" : (n.type === "member" ? "#ffbd80" : "#8aded8");
        });
        
        link.style("stroke", function(l) {
          const hasAnyClass = this.classList.length > 0;
          return hasAnyClass ? "#ff0000" : "#a6a6a6";
        });
      });

    // preclicked / selected nodes
    // Apply pre-clicked nodes (simulate actual clicks)
    if (clickedNodes?.nodes?.length) {
    clickedNodes.nodes.forEach(nodeName => {
        const targetNode = nodesData.find(n => n.name === nodeName);
        if (targetNode) {
        const nodeIndex = `node-${targetNode.index}`;
        
        // Mark as clicked and add classes (same as manual click)
        node.each(function(n) {
            if (n === targetNode) {
            d3.select(this).classed("clicked", true);
            }
            if (neighboring(targetNode, n) || n === targetNode) {
            d3.select(this).classed(nodeIndex, true);
            }
        });
        link.each(function(l) {
            if (l.source === targetNode || l.target === targetNode) {
            d3.select(this).classed(nodeIndex, true);
            }
        });
        }
    });
    
    // Apply colors with custom color
    const preClickColor = clickedNodes.color || "#ff0000";
    node.style("fill", function(n) {
        const hasAnyClass = this.classList.length > 0;
        return hasAnyClass ? preClickColor : (n.type === "member" ? "#ffbd80" : "#8aded8");
    });
    
    link.style("stroke", function(l) {
        const hasAnyClass = this.classList.length > 0;
        return hasAnyClass ? preClickColor : "#a6a6a6";
    });
    }



    const text = g.append("g")
      .selectAll("text")
      .data(nodesData)
      .enter()// Collision force
      .append("text")
      .attr("font-size", d => d.type === "member" ? memberFontScale(d.linkCount || 0) : institutionFontScale(d.linkCount || 0))
      .text(d => d.name)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .style("pointer-events", "none");

    svg.call(d3.zoom().on("zoom", e => g.attr("transform", e.transform)));

    simulation.on("tick", () => {
      link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
      node.attr("cx", d => d.x).attr("cy", d => d.y);
      text.attr("x", d => d.x).attr("y", d => d.y);
    });

    setTimeout(() => {
      if (rotation !== 0) {
        nodesData.forEach(translate);
        link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
        node.attr("cx", d => d.x).attr("cy", d => d.y);
        text.attr("x", d => d.x).attr("y", d => d.y);
      }
    }, 100);
  }

  initNetwork();
</script>

<style>
  .network-container { width: 100%; margin: 2rem 0 2rem 0rem;}
  circle { cursor: pointer; }
</style>
